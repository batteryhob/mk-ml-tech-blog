<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2021-06-05T10:57:58-05:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">머신러닝파트 기술블로그</title><subtitle></subtitle><entry><title type="html">2021년 6월 머신러닝파트 월간 리뷰</title><link href="http://0.0.0.0:4000/2021/06/04/MonthlyReport202106-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="2021년 6월 머신러닝파트 월간 리뷰" /><published>2021-06-04T10:00:00-05:00</published><updated>2021-06-04T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/04/MonthlyReport202106-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/04/MonthlyReport202106-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;과금넛지&quot;&gt;과금넛지&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;5차 실험 집행 후, 넛지 대상자의 반응 여부를 판단하기 위해 충전액 예측 모델링을 진행 중입니다.&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;u&gt;넛지 전후 충전액을 예측&lt;/u&gt;하여 유저의 반응 여부와 효과를 측정하기 위함입니다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;4월 리뷰 당시보다 효율적인 효과측정을 위해, 더 고도화된 모델링이 필요하다고 판단했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1차-충전액-예측-모델링의-과정&quot;&gt;1차 충전액 예측 모델링의 과정&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;1차에서 4차까지의 실험 결과와 Nxlog를 바탕으로 Feature를 만들어 여러가지 예측 모델에 집어넣어 성능을 평가했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;feature-extraction&quot;&gt;Feature Extraction&lt;/h3&gt;

&lt;p&gt;충전액을 예측할 수 있는 Feature를 분류별로 추줄해보았습니다.&lt;/p&gt;

&lt;p&gt;첫 번째, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;접속, 충전, 구매&lt;/code&gt;와 관련한 Features입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;접속횟수, 플레이타임, 미접속일수 등 접속 관련 세부 정보&lt;/li&gt;
  &lt;li&gt;구매횟수, 구매액 등 구매 관련 세부 정보&lt;/li&gt;
  &lt;li&gt;충전횟수, 충전액 등 충전 관련 세부 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 번째, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인구 통계&lt;/code&gt;와 관련한 Features입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성별, 나이&lt;/li&gt;
  &lt;li&gt;아이템 관련
    &lt;ul&gt;
      &lt;li&gt;PCA 기반 아이템 그룹 구매 count
        &lt;ul&gt;
          &lt;li&gt;(상위 100개 아이템 기준) 유저 아이템 메트릭스를 이용해 PCA로 item 그룹 생성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;유저별 아이템 구매 경험 및 가격
        &lt;ul&gt;
          &lt;li&gt;아이템 평균 가격, 평균 구매 가격, main 아이템 구매 여부 및 수량, 고가치 아이템 구매 여부 및 수량&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시샵 방문 관련
    &lt;ul&gt;
      &lt;li&gt;과거 방문횟수, 방문일수 등 관련 세부 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;model-fitting&quot;&gt;Model Fitting&lt;/h3&gt;

&lt;p&gt;목적??&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;유저별 30일간의 충전량 예측
사용 데이터&lt;/li&gt;
  &lt;li&gt;모델링 과정의 데이터는 대조군만을 사용 (넛지에 오염되지 않은 실험대상)&lt;/li&gt;
  &lt;li&gt;초반 과금량 분포를 보고, 전체 유저의 10퍼센트 정도의 상위 outlier 제거
    &lt;ul&gt;
      &lt;li&gt;outlier로 인해 오차가 커지는 것을 방지&lt;/li&gt;
      &lt;li&gt;전반적으로 과소추정하는 모델을 만들기 위함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;lightGBM&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;binary
    &lt;ul&gt;
      &lt;li&gt;약 75만 유저 중 46만이 무과금 유저로, 대부분 0(무과금)으로 예측하는 문제 발생&lt;/li&gt;
      &lt;li&gt;binary model로 무과금 유저를 걸러낸 후, regression model을 사용하여 오차를 줄이면서 동시에 납득할만한 예측치를 얻고자 함&lt;/li&gt;
      &lt;li&gt;보수적인 예측을 위해 label 1 (실제 과금 유저)에 대한 recall (실제 과금 유저를 과금으로 예측하는 것)을 스코어로 사용
        &lt;ul&gt;
          &lt;li&gt;이를 통해, 과금 가능성이 조금이라도 보이는 유저는 걸러지지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;label 1에 대한 recall 0.9, 0에 대한 recall 0.5 전후를 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;regression
    &lt;ul&gt;
      &lt;li&gt;MAPE 최소화 LightGBM 회귀 모델
        &lt;ul&gt;
          &lt;li&gt;모델 예측값이 대부분 0인 문제를 보임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MSE 최소화 LightGBM 회귀 모델
        &lt;ul&gt;
          &lt;li&gt;과금이 높은 유저에 대한 오차 패널티를 증대하여, 모델 예측값이 대부분 0인 문제를 완화하려는 시도&lt;/li&gt;
          &lt;li&gt;MAPE 최소화 LightGBM 회귀 모델에 비해 과금량이 많은 유저에 대한 오차가 상대적으로 작지만, 여전히 대부분 예측값이 0인 문제 잔재&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;binary 분류 → MAPE &amp;amp; MSE 최소화 LightGBM 회귀 모델
        &lt;ul&gt;
          &lt;li&gt;모델의 예측값이 대부분 0인 문제를 해결하기 위해, binary 분류 모델이 과금 유저라고 예측한 데이터만 사용하여 모델 트레이닝&lt;/li&gt;
          &lt;li&gt;분류 모델이 과금 유저라고 예측한 유저의 약 50%는 무과금 유저였고, 예측된 과금량은 여전히 대부분 0으로 예측&lt;/li&gt;
          &lt;li&gt;백분률 변환과 log 변환을 시도하였으나 큰 변화 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;KNN&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Base model을 위한 KNN
    &lt;ul&gt;
      &lt;li&gt;기존 모델과의 성능 비교를 위한 모델&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과금 여부 예측 이진 분류 LightGBM 모델 → KNN 회귀 모델
    &lt;ul&gt;
      &lt;li&gt;과금 여부 예측 이진 분류 모델이 1(과금 유저)로 예측한 데이터에 한해서 KNN 회귀 모델 적용&lt;/li&gt;
      &lt;li&gt;여전히 예측값이 0에 가까운 문제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;다음과 같은 성능을 보였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Model&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;alias&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;MAE&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;MAPE (+1000후 계산)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Baseline KNN&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;base_knn_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15960원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;671.80%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MAPE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mape_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;14694원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;27.88%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;16035원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;688.66%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → MAPE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_mape_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;14582원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;54.01%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;13799원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;485.77%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → Log 변환 후  MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_log_mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15003원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;44.52%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → 백분률 변환 후 MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_minmax_mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;13450원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;469.54%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → 백분률 변환 후 MAE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_minmax_mae_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12056원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;177.27%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → KNN 회귀모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_knn_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;14971원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;556.93%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/yeonsuuu/y_pred_error1.png&quot; alt=&quot;오차 그래프 1&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/yeonsuuu/y_pred_error2.png&quot; alt=&quot;오차 그래프 2&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1차-충전액-예측-모델링의-결론&quot;&gt;1차 충전액 예측 모델링의 결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;5차 실험을 진행하기에, 1차 충전액 예측 모델링은 &lt;u&gt;충분하지 못한 성능&lt;/u&gt;이 나왔습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대부분의 값을 0의로 예측했고, 충전여부를 예측하는 분류모델도 제대로 작동하지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;모델 성능에 문제가 있었던 점을 다음 3가지로 예상하고 있습니다.&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모델에 충분한 정보를 주지 않음
    &lt;ul&gt;
      &lt;li&gt;추가 feature 생성
        &lt;ul&gt;
          &lt;li&gt;개별 게임에 종속된 정보&lt;/li&gt;
          &lt;li&gt;cashflow에서 얻을 수 있는 정보&lt;/li&gt;
          &lt;li&gt;시계열 모델 예측결과 및 embedding&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관찰기간인 30일 간, 발생하는 외부 이벤트가 유저 구매행동에 영향을 줌
    &lt;ul&gt;
      &lt;li&gt;구매 행동에 영향을 줄 수 있는 외부 이벤트: 이탈, 게임 내 여론 변화, 확률형 아이템의 사용결과(운) 등등&lt;/li&gt;
      &lt;li&gt;모델에 가능한 한 많은 정보를 제공했음에도 스코어가 개선되지 않을 때 의심할 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유저의 구매행동이 충동적으로 일어나므로 예측이 불가
    &lt;ul&gt;
      &lt;li&gt;&lt;u&gt;&lt;b&gt;위의 모든 가능성을 다 탐색했음에도 모델 성능이 충분히 나오지 않을 경우, 예측이 불가능한 것으로 간주할 예정&lt;/b&gt;&lt;/u&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cashflow의 데이터의 이상&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Cashflow의 데이터의 이상이 있었지만, 해결완료.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cashflow-데이터-eda&quot;&gt;Cashflow 데이터 EDA&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;과금넛지-6월-계획&quot;&gt;과금넛지 6월 계획&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;과금넛지 프로젝트 6월 계획은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효과측정 도구 개발
    &lt;ul&gt;
      &lt;li&gt;두번째 루프로 진입하여 가설을 검증하고, 개발이 가능한지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새로운 넛지 시나리오 기획
    &lt;ul&gt;
      &lt;li&gt;충전액이 늘어나도록 유도하는 넛지
        &lt;ul&gt;
          &lt;li&gt;넛징을 받는 유저가 스스로 운이 좋다고 느끼게 하기&lt;/li&gt;
          &lt;li&gt;넛징으로 캐시 관련 자극을 반복적으로 받도록 설계하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;충전하는 주기가 짧아지도록 유도하는 넛지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;디지털-사이니지&quot;&gt;디지털 사이니지&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;디지털사이니지 마일스톤 중 FGT 웹 솔루션 제작 단계에 곧 돌입합니다. 또한, 아이덴티피케이션 모델 개발에 착수 했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;facialexpression-모델-개발&quot;&gt;FacialExpression 모델 개발&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;영상을 통해 감정을 추론하는 모델은 목표로 했던 수준의 &lt;u&gt;개발이 완료&lt;/u&gt;되어, &lt;u&gt;추론 결과를 바탕으로 리포트&lt;/u&gt;를 개발 중입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;identification-모델-개발&quot;&gt;Identification 모델 개발&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;오프라인 광고 집행 시, &lt;u&gt;사람들이 해당 광고를 얼마나 관심있게 봤는 가&lt;/u&gt;를 측정하기 위함입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;object-detection&quot;&gt;Object Detection&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;u&gt;몇명의 사람들이 광고앞에 있는가&lt;/u&gt;를 알기 위해 Object Detection 모델을 먼저 연구했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 연구에 사용될 모델을 선정했던 기준은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tensorflow 기반 모델&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;👉 &lt;a href=&quot;https://github.com/tensorflow/models/tree/master/research/object_detection&quot;&gt;&lt;u&gt;Tensorflow2 Object Detection Model zoo&lt;/u&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;비교적 최근 모델&lt;/li&gt;
  &lt;li&gt;해상도가 높은 모델(1024x1024)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;테스트에 사용된 모델들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CenterNet HourGlass104 1024x1024 (CenterNet)&lt;/li&gt;
  &lt;li&gt;EfficientDet D4 1024x1024 (EfficientDet)&lt;/li&gt;
  &lt;li&gt;SSD MobileNet V2 FPNLite 640x640 (MobileNet)&lt;/li&gt;
  &lt;li&gt;SSD ResNet152 FPN 1024x1024 (RetinaNet)&lt;/li&gt;
  &lt;li&gt;Fast R-CNN ResNet152 V1 1024x1024 (Fast R-CNN)&lt;/li&gt;
  &lt;li&gt;Mask R-CNN Inception ResNet V2 1024x1024 (Mask R-CNN)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;evaluation-1&quot;&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;선정된 모델의 테스트 결과, 다음과 같은 성능을 보였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;MODEL&lt;/th&gt;
      &lt;th&gt;사&lt;/th&gt;
      &lt;th&gt;람&lt;/th&gt;
      &lt;th&gt;찾&lt;/th&gt;
      &lt;th&gt;은&lt;/th&gt;
      &lt;th&gt;수&lt;/th&gt;
      &lt;th&gt;속도&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Image1&lt;/td&gt;
      &lt;td&gt;Image2&lt;/td&gt;
      &lt;td&gt;Image3&lt;/td&gt;
      &lt;td&gt;Image 4&lt;/td&gt;
      &lt;td&gt;Image 5&lt;/td&gt;
      &lt;td&gt;동영상전체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CenterNet&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;130.68s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EfficientDet&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;608.38s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MobileNet&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;293.48s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RetinaNet&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;514.89s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;201.66s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;311.81s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 결과에 대한 분석은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존 논문에서 조사한대로 R-CNN의 성능이 우수한 것이 확인&lt;/li&gt;
  &lt;li&gt;의야한 결과는 원래 SSD 계열들이 속도가 빠르게 나와야하는데 정확도와 속도 측면에서 이상 결과를 보임
    &lt;ul&gt;
      &lt;li&gt;구현된 다른 모델들을 찾아보고 보충실험을 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속도가 가장 빠른 모델은 CenterNet&lt;/li&gt;
  &lt;li&gt;추가적으로 Yolo 계열와 SSD 모델을 새로 찾아서 추가 실험을 진행해야하겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;디지털-사이니지-6월-계획&quot;&gt;디지털 사이니지 6월 계획&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;디지털 사이니지 프로젝트 6월 계획은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FacialExpression 모델 기반 데모 리포트 완료 및 UX실 공유&lt;/li&gt;
  &lt;li&gt;감정 리포트 프론트엔드 콘솔 구현&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pytorch Identification 기반 모델&lt;/code&gt; 연구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;머신러닝-파이프라인&quot;&gt;머신러닝 파이프라인&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;머신러닝파트는 1년 간 머신러닝 서비스 운영 기술적 노하우를 축적하려 노력했습니다. 공유할 수 있는 결과물이 나오기 시작했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;첫-번째-자체-bi를-도입했습니다-쿠버네티스-기반의-jupyterhub를-구축했습니다&quot;&gt;첫 번째, 자체 BI를 도입했습니다. 쿠버네티스 기반의 JupyterHub를 구축했습니다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;현재, 랩스내 많은 분석 조직에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EC2 기반 EMR 제플린&lt;/code&gt;을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;마케팅 개발실내에서는 컨텐츠 서비스 개발팀, ADS 개발팀이 그러합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일 서버 프로세스&lt;/code&gt;를 사용하는 제플린은 많은 사용자가 동시 사용에 사용할 수 있으나,&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;일부 작업이 리소스가 많이 필요할 경우, 전체 리소스에 영향을 주어 다른 작업자의 작업을 방해하는 경우가 많습니다.&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;최악의 경우, 제플린 서버의 프로세스가 멈추어, EC2를 재시작하는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;때문에, 작업자마다 완전히 분리된 독립적인 분석 환경과 테스트 환경을 제공해줘야 합니다.&lt;/p&gt;

&lt;p&gt;머신러닝 파트는 쿠버네티스 기반의 JupyterHub를 구축하여 가능하게 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;http://mlhub.na.nexon.co.kr&quot;&gt;&lt;u&gt;머신러닝파트 주피터허브&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;/2021/06/03/ApacheZeppelinVsJupyter-전지호.html&quot;&gt;&lt;u&gt;제플린과 주피터의 비교&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스 기반의 주피터허브는 사용자가 로그인 시, 그때마다 독립적인 도커 컨테이너를 만듭니다.&lt;/p&gt;

&lt;p&gt;독립된 컨테이너에서 실행되는 작업이 리소스가 부족해 폭파되더라도, 다른 컨테이너에 영향을 줄 수 없습니다.&lt;/p&gt;

&lt;p&gt;각 컨테이너마다 분석에 쓰이고자 하는 라이브러리 사양을 골라서 만들수 있고, 해당 컨테이너는 커스터 마이징이 가능합니다.&lt;/p&gt;

&lt;p&gt;머신러닝파트는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nxlog에 접근할 수 있는 Hadoop 기반의 pyspark 컨테이너&lt;/li&gt;
  &lt;li&gt;Pytorch 컨테이너&lt;/li&gt;
  &lt;li&gt;Tensorflow 컨테이너&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3개의 컨테이너를 내부 사양에 맞게 커스터마이징하여 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;10분 간, 사용하지 않는 컨테이너는 자동으로 내려갑니다. 따라서 쿠버네티스내 리소스는 효율적으로 관리됩니다.&lt;/p&gt;

&lt;p&gt;전 세계에서 가장 유명한 머신러닝와 데이터 분석도구인 kubeflow, sagemaker, 데이터브릭스에서 제공하는 기능입니다.&lt;/p&gt;

&lt;p&gt;기술 공유를 통해 각 조직마다 구축해 내부적으로 사용할 수 있을 것으로 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;두-번째-mlops-cicd를-도입했습니다&quot;&gt;두 번째, MLOps CI/CD를 도입했습니다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;아시다시피, 일반 웹서비스처럼 머신러닝 혹은 분석 서비스 또한 라이브 레벨에서는 많은 유지 보수의 비용이 들어갑니다.&lt;/p&gt;

&lt;p&gt;현재의 경우처럼 Job을 만들어 airflow로 실행하는 형태의 업무는 실제 대규모 서비스 레벨에 올라갈 경우, 많은 문제를 야기할 수 있습니다.&lt;/p&gt;

&lt;p&gt;일단, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;형상관리&lt;/code&gt;가 되지 않습니다.&lt;/p&gt;

&lt;p&gt;작업자가 실수를 범하여 서비스 단계에 잘못된 소스가 올라갈 경우,&lt;/p&gt;

&lt;p&gt;롤백에 취약하고 최악의 경우에 이전 코드를 찾을 수 없는 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;공동 작업의 경우, 코드를 수정한 사람이나, 배포를 한 사람을 찾아내기 힘들 수도 있습니다.&lt;/p&gt;

&lt;p&gt;서든어택 월핵탐지기 경우처럼 다른 조직과 협업하여 하루에 수십만 건 이미지를 머신러닝 코드로 처리하는 프로세스와 같은 서비스가 있다면, 이러한 취약점은 감당하기 힘든 문제로 돌아올 수 도 있습니다. 인텔리전스랩스의 분석 및 머신러닝 서비스가 네이버페이, 카카오페이같은 일반 사용자 대상 금융 서비스라고 가정하면 대부분의 분석 서비스가 큰 어려움을 겪을 것이라고 쉽게 생각할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에, 머신러닝 파이프라인에 MLOps라 불리는 CI/CD를 적용했습니다.&lt;/p&gt;

&lt;p&gt;현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;월핵탐지&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FGT 감정추론&lt;/code&gt;의 경우,&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;개발자의 도움없이 작업자가 코드만 수정하여 배포, 롤백, 형상관리, 모니터링이 모두 가능합니다.&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://a4b2cf330e1d2464a951ba793aaae70e-596153973.ap-northeast-2.elb.amazonaws.com/&quot;&gt;&lt;u&gt;월핵탐지기 모니터링 ArgoCD&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://ad1f03f16a72740d68c582a87b928f1b-1924335043.ap-northeast-2.elb.amazonaws.com/&quot;&gt;&lt;u&gt;FGT 실시간 감정추론 모니터링 ArgoCD&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;옥외광고-지역-선정&quot;&gt;옥외광고 지역 선정&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;넥슨 유저의 위치정보 기반의 지역을 선정하다가 위치 기반 데이터의 한계를 느끼고 옥외 광고의 성과를 추적할 수 있는 새로운 아이데이션을 시도했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;상시-업무&quot;&gt;상시 업무&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;넥슨과 인텔리전스랩스에 도움이 되는 업무를 지속적으로 하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마무리한다&lt;/p&gt;</content><author><name>전지호</name></author><category term="monthlyreport" /><summary type="html">과금넛지와 디지털사이니지, 오프라인 광고지역 선정에 대한 리뷰입니다.</summary></entry><entry><title type="html">월말보고(5월)- 최혁근</title><link href="http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EC%B5%9C%ED%98%81%EA%B7%BC.html" rel="alternate" type="text/html" title="월말보고(5월)- 최혁근" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EC%B5%9C%ED%98%81%EA%B7%BC</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EC%B5%9C%ED%98%81%EA%B7%BC.html">&lt;h1 id=&quot;face-identification-시스템&quot;&gt;Face Identification 시스템&lt;/h1&gt;

&lt;h2 id=&quot;face-identification-시스템-1&quot;&gt;Face Identification 시스템&lt;/h2&gt;
&lt;h3 id=&quot;개요&quot;&gt;개요&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;필요성
    &lt;ul&gt;
      &lt;li&gt;오프라인 광고측정의 첫걸음&lt;/li&gt;
      &lt;li&gt;사람들은
        &lt;ul&gt;
          &lt;li&gt;광고를 얼마나 보는가?&lt;/li&gt;
          &lt;li&gt;얼마나 집중하는가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이런 것을 어떻게 측정할 것인가?
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;카메라 + 얼굴인식으로 이걸 파악해보자&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;방법
    &lt;ul&gt;
      &lt;li&gt;카메라가 설치된 디지털 전광판에 광고를 송출
        &lt;ul&gt;
          &lt;li&gt;광고는 태그와 메타데이터로 어떤 종류의 광고인지 추적 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;광고 송출중에 카메라 앞으로 다니는 사람들을 파악
        &lt;ul&gt;
          &lt;li&gt;화면에 잡힌 사람들을 개별적으로 인식&lt;/li&gt;
          &lt;li&gt;DB에서 사람들을 누구인지 특징 / 추가 / 추적&lt;/li&gt;
          &lt;li&gt;사람들이 광고에 시청여부 판단&lt;/li&gt;
          &lt;li&gt;사람들의 집중시간 판단&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;광고별 시청률 / 집중률 등등 통계자료를 report&lt;/li&gt;
      &lt;li&gt;관리자 모드에는 실시간 관찰 UI&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세부기능 &amp;amp; 기술스택
    &lt;ul&gt;
      &lt;li&gt;사람 인식
        &lt;ul&gt;
          &lt;li&gt;Object Detection&lt;/li&gt;
          &lt;li&gt;Human Detecetion&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;얼굴 인식
        &lt;ul&gt;
          &lt;li&gt;Face Detection&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사람 분류
        &lt;ul&gt;
          &lt;li&gt;Face embedding&lt;/li&gt;
          &lt;li&gt;Face Verification / Identification&lt;/li&gt;
          &lt;li&gt;Similarity&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;광고시청 / 집중
        &lt;ul&gt;
          &lt;li&gt;Head Pose Estimation&lt;/li&gt;
          &lt;li&gt;Eye tracking&lt;/li&gt;
          &lt;li&gt;Engagement detection&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사람 정보 저장
        &lt;ul&gt;
          &lt;li&gt;ID&lt;/li&gt;
          &lt;li&gt;방문횟수&lt;/li&gt;
          &lt;li&gt;머문 시간&lt;/li&gt;
          &lt;li&gt;시청한 시간&lt;/li&gt;
          &lt;li&gt;사진정보&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요구사항
    &lt;ul&gt;
      &lt;li&gt;성능&lt;/li&gt;
      &lt;li&gt;속도&lt;/li&gt;
      &lt;li&gt;장비&lt;/li&gt;
      &lt;li&gt;환경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일정
    &lt;ul&gt;
      &lt;li&gt;개발&lt;/li&gt;
      &lt;li&gt;서베이
        &lt;ul&gt;
          &lt;li&gt;기술&lt;/li&gt;
          &lt;li&gt;논문&lt;/li&gt;
          &lt;li&gt;기타&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;문제점 분석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;시스템-세부사항&quot;&gt;시스템 세부사항&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;카메라 대기 (동영상으로도 테스트 가능)
    &lt;ul&gt;
      &lt;li&gt;Cam에서 영상을 프레임 단위로 분리 / 이미지화&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;화질 / 영상 사이즈 고려&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;화면에서 사람 / 얼굴 인식
    &lt;ul&gt;
      &lt;li&gt;Object Detection&lt;/li&gt;
      &lt;li&gt;Face Detection&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사람 ID 확인
    &lt;ul&gt;
      &lt;li&gt;얼굴 사진을 embedding해서 vector로 변환&lt;/li&gt;
      &lt;li&gt;기존 DB에 similarity 계산, 유사도가 높은 순 정리&lt;/li&gt;
      &lt;li&gt;Top1, Top5 등등을 통해서 사람 선별 기준 확립&lt;/li&gt;
      &lt;li&gt;얼굴이 아닌 사람 전체 모습을 통해서 이전 프레임과의 연관성을 통해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tracking
    &lt;ul&gt;
      &lt;li&gt;확인한 사람을 frame단위로 계속 마킹해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;추가적으로-리서치가-필요한-분야&quot;&gt;추가적으로 리서치가 필요한 분야&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Human Pose Estimation
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/MVIG-SJTU/AlphaPose&quot;&gt;AlphaPose&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/facebookresearch/DetectAndTrack&quot;&gt;Detect And Track&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Object Tracking&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;research1--object-detection&quot;&gt;Research1 : Object Detection&lt;/h2&gt;
&lt;h3 id=&quot;개요-1&quot;&gt;개요&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사람을 인식하기 위해서는 기존의 물체 인식 (Object Detection) 모델들을 사용한다.&lt;/li&gt;
  &lt;li&gt;실시간으로 진행하기 위해서는 추론 속도가, 후처리를 하기 위해서는 정확도가 중요하다.&lt;/li&gt;
  &lt;li&gt;연구된 여러 가지 구현체들을 실험용 데모영상을 이용해서 정확도와 속도를 측정하고&lt;/li&gt;
  &lt;li&gt;우리 시스템에 어울리는 모델이 무엇일지를 선별한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실험설계&quot;&gt;실험설계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 데이터
    &lt;ul&gt;
      &lt;li&gt;동영상 파일&lt;/li&gt;
      &lt;li&gt;가장 일반적인 거리영상인 지하철입구 영상&lt;/li&gt;
      &lt;li&gt;많은 사람들이 지나다닐 때 사람들을 정확히 포착할 수 있는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 동영상 &lt;a href=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/4k-002.mkv&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-1-tensorflow-object-detection-zoo&quot;&gt;1-1. Tensorflow Object Detection Zoo&lt;/h2&gt;
&lt;h3 id=&quot;1-테스트-개요&quot;&gt;1. 테스트 개요&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 모델
    &lt;ul&gt;
      &lt;li&gt;Object Detection 6가지 모델
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://github.com/tensorflow/models/tree/master/research/object_detection&quot;&gt;Tensorflow2 Object Detection Model zoo&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;기존에 한번식 break-through를 만들어냈던 모델들&lt;/li&gt;
          &lt;li&gt;최근 소개된 모델들도 추가해서&lt;/li&gt;
          &lt;li&gt;해상도가 높은 모델들 선정 (1024x1024)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;선정된 모델들
        &lt;ul&gt;
          &lt;li&gt;CenterNet HourGlass104 1024x1024 (CenterNet)&lt;/li&gt;
          &lt;li&gt;EfficientDet D4 1024x1024 (EfficientDet)&lt;/li&gt;
          &lt;li&gt;SSD MobileNet V2 FPNLite 640x640 (MobileNet)&lt;/li&gt;
          &lt;li&gt;SSD ResNet152 FPN 1024x1024 (RetinaNet)&lt;/li&gt;
          &lt;li&gt;Fast R-CNN ResNet152 V1 1024x1024 (Fast R-CNN)&lt;/li&gt;
          &lt;li&gt;Mask R-CNN Inception ResNet V2 1024x1024 (Mask R-CNN)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 방법
    &lt;ol&gt;
      &lt;li&gt;정확도 테스트
        &lt;ul&gt;
          &lt;li&gt;임의로 선별한 몇 개의 이미지에 대해서&lt;/li&gt;
          &lt;li&gt;개별 모델을 실행해서 물체를 인식하고&lt;/li&gt;
          &lt;li&gt;그 중에서 사람으로 판단하는 확률이 50% 이상인 결과들에 대해서&lt;/li&gt;
          &lt;li&gt;Box 표시하고 이미지로 출력&lt;/li&gt;
          &lt;li&gt;몇 명이나 사람을 찾아냈는지, 잘못 인식한 것은 얼마나 되는지 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;추론 속도 테스트
        &lt;ul&gt;
          &lt;li&gt;동영상 전체를(10초, 600 frams)&lt;/li&gt;
          &lt;li&gt;프레임별로 읽으면서&lt;/li&gt;
          &lt;li&gt;모델 추론을 진행하고 결과를 확인해보는 방식&lt;/li&gt;
          &lt;li&gt;추론 시 batchsize를 1, 5로 변화시켜가면서 시간 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 테스트를 해보고 우리 환경에 맞는 모델을 선정하는 것이 목표&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-사람인식-테스트&quot;&gt;2. 사람인식 테스트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;MODEL&lt;/th&gt;
      &lt;th&gt;사&lt;/th&gt;
      &lt;th&gt;람&lt;/th&gt;
      &lt;th&gt;찾&lt;/th&gt;
      &lt;th&gt;은&lt;/th&gt;
      &lt;th&gt;수&lt;/th&gt;
      &lt;th&gt;속도&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Image1&lt;/td&gt;
      &lt;td&gt;Image2&lt;/td&gt;
      &lt;td&gt;Image3&lt;/td&gt;
      &lt;td&gt;Image 4&lt;/td&gt;
      &lt;td&gt;Image 5&lt;/td&gt;
      &lt;td&gt;동영상전체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CenterNet&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;130.68s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EfficientDet&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;608.38s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MobileNet&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;293.48s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RetinaNet&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;514.89s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;201.66s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;311.81s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;테스트결과 (TODO : 링크주소 수정)
    &lt;ul&gt;
      &lt;li&gt;Image1
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result1.png&quot; alt=&quot;테스트결과1&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image2
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result2.png&quot; alt=&quot;테스트결과2&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image3
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result3.png&quot; alt=&quot;테스트결과3&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image4
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result4.png&quot; alt=&quot;테스트결과4&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image5
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result5.png&quot; alt=&quot;테스트결과5&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-결과분석-및-여담&quot;&gt;3. 결과분석 및 여담&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기존 논문에서 조사한대로 R-CNN의 성능이 우수한 것이 확인됌&lt;/li&gt;
  &lt;li&gt;의야한 결과는 원래 SSD 계열들이 속도가 빠르게 나와야하는데 정확도와 속도 측면에서 결과가 이상해보인다.
    &lt;ul&gt;
      &lt;li&gt;구현된 다른 모델들을 찾아보고 보충실험을 진행해봐야하겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CenterNet의 경우도 좋은 성능을 보여주고 있다. 이번 실험에서는 속도도 가장 빨랐다.&lt;/li&gt;
  &lt;li&gt;추가적으로 Yolo계열와 SSD 모델을 새로 찾아서 추가실험을 진행해야하겠다.&lt;/li&gt;
  &lt;li&gt;이 모델에 추가해서 얼굴인식 모델들도 결합해서 함께 진행해보자!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-앞으로-진행해야할-내용&quot;&gt;4. 앞으로 진행해야할 내용&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Pytorch 모델들 조사
    &lt;ul&gt;
      &lt;li&gt;간단하게 테스트해본 결과&lt;/li&gt;
      &lt;li&gt;이쪽 모델들이 사용하거나 변형하기가 훨씬 쉬어보인다.&lt;/li&gt;
      &lt;li&gt;제일 기본적인 예제 - &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html#torchvision-object-detection-finetuning-tutorial&quot;&gt;TORCHVISION OBJECT DETECTION FINETUNING TUTORIAL&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;이런 식으로 사람만을 대상으로하는 detection 모델 개발 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 기법들 조사 및 적용&lt;/li&gt;
  &lt;li&gt;자체 학습하면 어떻게 데이터를 구하고 어떻게 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-2-pytorch-test&quot;&gt;1-2. Pytorch Test&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 진행중&lt;/li&gt;
  &lt;li&gt;torchvision에서 기본으로 제공되는 모델이
    &lt;ul&gt;
      &lt;li&gt;Mask R-CNN ResNet50 FPN&lt;/li&gt;
      &lt;li&gt;Tensorflow의 Mask R-CNN에서 backbone architecture로 사용된 Inception ResNet V2 1024x1024보다 가벼운 모델&lt;/li&gt;
      &lt;li&gt;이 모델 최상단에 추가로 Layer를 하나 더 두고 Person Class만을 따로 디텍션하도록 fine tuning 하는 tutorial이 존재&lt;/li&gt;
      &lt;li&gt;이 과정만으로도 훨씬 무거운 tensorflow모델보다 빠르고 비슷한 성능을 보이는 것으로 확인됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델 다루기나 코딩도 pytorch 쪽이 훨씬 편리하기 때문에 이걸 중심으로 개발 진행
    &lt;ul&gt;
      &lt;li&gt;대신 성능 관련해서는 확실하게 문서화 진행 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>최혁근</name></author><category term="computervision" /><category term="objectdetection" /><summary type="html">5월 보고용 자료입니다.</summary></entry><entry><title type="html">Apache Zeppelin와 Jupyter의 비교</title><link href="http://0.0.0.0:4000/2021/06/03/ApacheZeppelinVsJupyter-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="Apache Zeppelin와 Jupyter의 비교" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/ApacheZeppelinVsJupyter-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/ApacheZeppelinVsJupyter-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;아피치-제플린과-주피터의-간단-비교&quot;&gt;아피치 제플린과 주피터의 간단 비교&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 분석의 워크플로를 개선하는 아파치 제플린과 주피터를 간단하게 비교해볼께요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-설치-&quot;&gt;1. 설치 🛠&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;설치 단계에서부터 막히면, 아주 짜증이 많이납니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주피터의 설치는 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;그냥 명령어를 통해 로컬에 설치만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;로컬 환경을 쉽게 서버에 올리기 위해, 버전 별로 빌드된 도커 버전도 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%A3%BC%ED%94%BC%ED%84%B0%20%EC%84%A0%ED%83%9D.JPG&quot; alt=&quot;다양한 주피터 도커&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html&quot;&gt;주피터&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://github.com/jupyter/docker-stacks&quot;&gt;주피터 도커 깃허브&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그에 비해, 제플린의 설치는 조금 더 복잡합니다. 압축을 풀고 서버에서 실행해야 하죠.&lt;/p&gt;

&lt;p&gt;많은 기능을 함께 사용할려면 소스를 빌드하고 다시 실행해하는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;첫 번째 대결은, 주피터의 손을 들어줍니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-커뮤니티-&quot;&gt;2. 커뮤니티 💬&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;큰 커뮤니티는 레퍼런스와 도움을 받기 위해 아주 중요한 요소입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jupyter의 커뮤니티는 이 Zeppelin보다 상당히 크고 훨씬 더 많은 외부 시스템을 지원합니다.&lt;/p&gt;

&lt;p&gt;그러나 Zeppelin의 커뮤니티는 성장 중이나 아직은 Jupyter에 밀리는 모습을 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;두 번째 대결은, Jupyter의 손을 들어줍니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/compatition.jpg&quot; alt=&quot;구글 트렌드 비교&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-다중-사용자-지원-&quot;&gt;3. 다중 사용자 지원 👨‍👩‍👦‍👦&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;공용 환경에서 다중 사용자 지원은 필수입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zeppelin는 다중 사용자를 지원하며,  Jupyter는 다중 사용자를 지원하지 않습니다.&lt;/p&gt;

&lt;p&gt;세 번째 대결은, Zeppelin의 승리일까요?&lt;/p&gt;

&lt;p&gt;JupyterHub라는 Jupyter 확장 리소스는 다중 사용자 지원을 약속합니다.&lt;/p&gt;

&lt;p&gt;하지만 Zeppelin에 비해 Jupyter는 사용자마다 별도의 서버가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;이어질 내용으로 인해 이번 대결은 보류하겠습니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-다중-사용자-지원-시-리소스-분배-&quot;&gt;4. 다중 사용자 지원 시 리소스 분배 👨‍👩‍👦‍👦&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중 사용자가 많은 리소스를 동시에 사용할 때, 이에 대한 대응은 어떨까요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zeppelin은 서버 단일 프로세스를 사용합니다. 다중 사용자의 이용에 취약하죠.&lt;/p&gt;

&lt;p&gt;이를 회피하기 위해, conda 환경과 docker를 Zeppelin 내부에서 지원합니다.&lt;/p&gt;

&lt;p&gt;Jupyter는 어떨까요?&lt;/p&gt;

&lt;p&gt;Jupyter는 애초에 다중 사용자를 지원하지않으니, JupyterHub를 살펴봅시다.&lt;/p&gt;

&lt;p&gt;JupyterHub는 각 사용자마다 서버를 따로 제공해야하니 단일 서버 프로세스를 사용한다 하더라도, 서로 영향을 주지 않습니다.&lt;/p&gt;

&lt;p&gt;하지만 각각의 서버를 구축하는 비용에 대한 문제는 어떻게 할까요?&lt;/p&gt;

&lt;p&gt;JupyterHub는 쿠버네티스 환경을 제공하는 버전을 따로 내놨습니다.&lt;/p&gt;

&lt;p&gt;하나의 서버에서 동작하는 쿠버네티스 환경에서의 JupyterHub는 각각의 사용자에 대해 가상의 컨테이너를 제공하여, 분리된 작업환경을 제공하는 동시에 서버 구축 비용을 줄일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;네 번째 대결은, 주피터의 손을 들어줍니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-확장프로그램-&quot;&gt;5. 확장프로그램 📥&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 많은 기능을 사용하고 싶다면…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jupyter는 약 20 개만있는 Zeppelin의 인터프리터 유형에 대해 지원되는 엔진이 85 개가 넘는 큰 목록으로 인해 승리합니다. 다양한 언어를 사용하고 싶다면, 주피터를 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-차트---&quot;&gt;6. 차트 📊 📈 📉&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 시각화를 이용하여, 비주얼라이징 툴을 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jupyter와 Zeppelin을 둘 다 다양한 비주얼라이징 툴을 플로팅하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;따라서, 대결은 무승부입니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-결론&quot;&gt;7. 결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;개인의 선호도에 따라, 선택은 자유.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하지만, 많은 부분에서 Jupyter의 우세를 점칠 수 있습니다. 최근 가장 핫한 개발트렌드인 docker와 쿠버네티스 지원이 우수한 것은 차이를 더 크게 만드는 요소일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;위와 같은 이유로,&lt;/p&gt;

&lt;p&gt;우리 팀은 &lt;b&gt;&lt;u&gt;쿠버네티스 환경에 JupyterHub&lt;/u&gt;&lt;/b&gt;를 구축하여 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;도움이 되셨길 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/netflixjupyter.png&quot; alt=&quot;넷플릭스도 쓰는 주피터&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;안녕👋&lt;/p&gt;</content><author><name>전지호</name></author><category term="zeppelin" /><category term="jupyter" /><summary type="html">데이터 분석의 워크플로를 개선하는 아파치 제플린과 주피터를 간단하게 비교해볼께요.</summary></entry><entry><title type="html">AWS S3 데이터 Lifecycle 기능을 이용하여 정리하기</title><link href="http://0.0.0.0:4000/2021/06/03/S3Lifecycle-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS S3 데이터 Lifecycle 기능을 이용하여 정리하기" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/S3Lifecycle-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/S3Lifecycle-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;너는-어쩜-정리도-안하고-방을-돼지우리-같이-하고-사니&quot;&gt;“너는 어쩜 정리도 안하고 방을 돼지우리 같이 하고 사니…”&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리, S3라도 정리합시다. 꿀꿀 🐷&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Amazon S3를 이용하여 로그 및 분석 결과 혹은 파일을 저장하여 사용하다 보면 어느새 너무 많은 양의 데이터가 축적됩니다.&lt;/p&gt;

&lt;p&gt;데이터가 많아지면 많아질 수록, 스토리지 요금도 엄청나게 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%97%84%EC%B2%AD%EB%82%9C%EC%9A%A9%EB%9F%89.JPG&quot; alt=&quot;엄청난 용량&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 중 사용하는 데이터나 파일은 상관이 없으나, 사용하지 않는 데이터가 너무 많이 쌓이면 문제가 발생할 수 도 있습니다.&lt;/p&gt;

&lt;p&gt;AWS Concsole이나 S3 Browser를 통해 데이터에 접근할 때, 많은 데이터 조회에 속도가 느려지는 현상도 목격할 수 있어요.&lt;/p&gt;

&lt;p&gt;S3의 Lifecycle 기능을 이용하여 S3 버킷에 있는 데이터를 삭제하고 관리할 수 잇는 방법을 알아봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;amazon-s3-lifecycle-기능-사용하기&quot;&gt;Amazon S3 Lifecycle 기능 사용하기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;먼저, AWS Concsole로 S3 메뉴로 접근합니다.&lt;/p&gt;

&lt;p&gt;그리고 버킷 리스트 중 정리를 할 S3 버킷을 클릭해 접근해보면 &lt;u&gt;&lt;b&gt;관리&lt;/b&gt;&lt;/u&gt;라는 메뉴가 보여요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EB%B2%84%ED%82%B7%EC%A0%91%EA%B7%BC.JPG&quot; alt=&quot;S3 버킷 접근&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;수명 주기 규칙 생성&lt;/b&gt;&lt;/u&gt;버튼을 눌러서 생성화면으로 접근합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%83%9D%EC%84%B1%ED%99%94%EB%A9%B40.JPG&quot; alt=&quot;수명주기 생성화면1&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같은 화면을 볼 수 있어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%83%9D%EC%84%B1%ED%99%94%EB%A9%B41.JPG&quot; alt=&quot;수명주기 생성화면2&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수명 주기의 이름을 생성한 후, 범위를 지정해야 합니다.&lt;/p&gt;

&lt;p&gt;범위를 지정하지 않으면, 모든 객체가 해당 수명 주기의 영향을 받으니 주의해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;보통은 파일명(접두사)로 구분합니다. 접두사를 입력해주시면, 해당 접두사에 포함된 항목만 수명 주기에 영향을 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;접두사란&quot;&gt;접두사란?&lt;/h3&gt;

&lt;p&gt;S3에서 파일의 구조를 보면&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;버킷이름/상위폴더명/하위폴더명/파일명&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;이렇게 된 폴더 구조를 볼 수 있는데, 이는 실제로는 폴더 구조가 아니라 폴더+파일명이 하나의 Key로 취급됩니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에, 접두사는 파일명에 앞에 붙는 Key의 구분자라고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;따라서, 바로 위의 경우는 버킷이름을 제외하고 슬래시를 포함하여(/)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;상위폴더명/하위폴더명/&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;까지가 해당 파일 Key의 접두사라고 보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;수명-주기의-규칙&quot;&gt;수명 주기의 규칙&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%83%9D%EC%84%B1%ED%99%94%EB%A9%B42.JPG&quot; alt=&quot;수명주기 생성화면3&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수명 주기의 규칙은 잘 쓰지 않는 마지막 조건을 제외하고, 4가지 조건을 볼 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스토리지 클래스 간에 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재&lt;/code&gt;버전 반환
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최신&lt;/code&gt; 버전으로 취급되는 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스토리지 클래스 간에 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt;버전 반환
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt; 버전으로 취급되는 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재&lt;/code&gt; 버전 만료
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최신&lt;/code&gt; 버전으로 취급되지 않을 때까지의 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt; 버전 영구 삭제
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt; 버전으로 취급되어 영구적으로 삭제될 때까지의 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;저의 경우에는,&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;S3에 업로드된 객체가 30일 후에 이전 버전으로 취급되고,&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;이전 버전이 된 지 60일이나 지나면 삭제하고 싶었습니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;결국, 총 90일 후 S3에 적재된 리소스를 삭제하고 싶었으므로,&lt;/p&gt;

&lt;p&gt;2번과, 4번 조건을 이용해 수명 주기를 생성했습니다.&lt;/p&gt;

&lt;p&gt;완료 버튼을 눌러 생성을 완료합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%83%9D%EC%84%B1%EC%99%84%EB%A3%8C.JPG&quot; alt=&quot;생성완료&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상세 화면을 보면 등록된 수명 주기를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8%ED%99%95%EC%9D%B8.JPG&quot; alt=&quot;수명 주기 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS S3 Lifecycle 기능을 사용하여 스토리지 요금을 줄이고, 복잡하지 않은 S3 파일 관리가 가능해졌습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞으로는 집에서 잔소리를 좀 듣더라도 데이터만이라도 잘 정리하여&lt;/p&gt;

&lt;p&gt;효과적인 업무를 할 수 있도록 노력합시다.&lt;/p&gt;

&lt;p&gt;그럼 20,000👋&lt;/p&gt;</content><author><name>전지호</name></author><category term="aws" /><summary type="html">S3를 이용하여 로그 및 분석 결과 혹은 파일을 저장하여 사용하다 보면 어느새 너무 많은 양의 데이터가 축적됩니다. 이 중 사용하는 데이터나 파일은 상관이 없으나, 사용하지 않는 데이터가 너무 많이 쌓이면 문제가 발생할 수 도 있습니다. AWS Concsole이나 S3 Browser를 통해 이를 삭제하고 관리할 수 잇는 방법을 알아봅시다.</summary></entry><entry><title type="html">AWS Aurora DB, Mysql DB에서 스케줄러 사용하는 방법</title><link href="http://0.0.0.0:4000/2021/06/02/MysqlEvent-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS Aurora DB, Mysql DB에서 스케줄러 사용하는 방법" /><published>2021-06-02T10:00:00-05:00</published><updated>2021-06-02T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/02/MysqlEvent-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/02/MysqlEvent-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;aws-auroradb-mysql-db-에서-스케줄러-사용하는-방법-&quot;&gt;AWS AuroraDB, Mysql DB 에서 스케줄러 사용하는 방법 🕘&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS AuroraDB에서 데이터 사용을 용이하게 하기 위해 스케줄러를 사용해봅시다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;AWS에서 사용하는 RDB 데이터베이스인 AuroraDB에서 스케줄러를 사용하는 방법을 설명합니다.&lt;/p&gt;

&lt;p&gt;굉장히 많은 데이터가 일반 RDB에 쌓일 경우, 불가피하게 속도에 영향을 끼칠 수 있습니다.&lt;/p&gt;

&lt;p&gt;한 예로, 1 번의 쿼리로 데이터를 삭제하기 너무 많은 시간이 필요할 수 있습니다.&lt;/p&gt;

&lt;p&gt;스케줄러를 적절히 사용하면 데이터 관리를 용이하게 할 수 있을 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이벤트-스케줄을-생성하는-기본-문법-️&quot;&gt;이벤트 스케줄을 생성하는 기본 문법 ✏️&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;먼저 기본 문법을 알아봅시다. workbench 등을 통해 접근하여 다음과 같은 문법으로 이벤트를 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCHEDULE&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수행&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;반복&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;시간&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMPLETION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRESERVE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;코멘트&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수행할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명령&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실제-쿼리를-작성해봅시다-️&quot;&gt;실제 쿼리를 작성해봅시다. ✏️&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;일단, 매 시간마다 데이터를 삭제하는 예제 쿼리를 작성해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_DELETE_ROW_BEFORE_180DAY&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCHEDULE&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MINUTE&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;분&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;마다&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOUR&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMPLETION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRESERVE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'현재일로 부터 180일 전 데이터는 삭제'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt; 

    &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수행할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스케줄러-onoff&quot;&gt;스케줄러 On/Off&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;쿼리 작성을 완료했다면, 해당 데이터베이스가 스케줄러가 작동가능한 지 확인해봅시다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLES&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'event_scheduler'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.JPG&quot; alt=&quot;이벤트 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;작동이 가능하지 않다면 아래 명령어를 통해 스케줄러 기능을 사용가능하게 바꿔주세요.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GLOBAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_scheduler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AWS에서는 AuroraDB를 처음 만들었을 때, 파라미터 그룹(Parameter groups)이라는 설정값에 의해 스케줄러가 on/off를 할 수 없는 상태로 생성됬을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;AWS console에서 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;데이터 베이스의 파라미터 그룹을 확인해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B7%B8%EB%A3%B9.JPG&quot; alt=&quot;데이터 베이스 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;default.aurora5.6라는 기본 파라미터 그룹으로 생성된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B7%B8%EB%A3%B91.JPG&quot; alt=&quot;파라미터 그룹 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이벤트 스케줄러가 변경이 가능하도록 되어있으나, 기본 파라미터 그룹은 값 변경이 되지 않습니다. 그렇기 때문에, 새 파라미터 그룹을 생성하고 데이터베이스 파라미터 그룹을 변경해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%20%EB%B3%80%EA%B2%BD.JPG&quot; alt=&quot;파라미터 변경&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 파라미터 그룹을 생성했다면 파라미터를 변경 후, 데이터베이스 파라미터 그룹을 생성한 파라미터 그룹으로 변경한다.
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;변경이 가능한 파라미터 그룹이라면 파라미터만 변경한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;적용 후, 데이터베이스 재부팅을 통해 파라미터가 변경이 적용되게 하세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%9E%AC%EB%B6%80%ED%8C%85.JPG&quot; alt=&quot;재부팅&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;재부팅이 완료된 후, 다시 명령어로 확인해봅니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLES&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'event_scheduler'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%20%EB%B3%80%EA%B2%BD%20%EC%99%84%EB%A3%8C.JPG&quot; alt=&quot;파라미터 변경 완료&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 이벤트 스케줄러를 등록할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이벤트-스케줄러-등록-&quot;&gt;이벤트 스케줄러 등록 📅&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;예제 쿼리를 실행합니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_DELETE_ROW_BEFORE_180DAY&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCHEDULE&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MINUTE&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;분&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;마다&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOUR&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMPLETION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRESERVE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'현재일로 부터 180일 전 데이터는 삭제'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt; 

    &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수행할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;등록된 이벤트는 다음 명령어로 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EB%93%B1%EB%A1%9D%EB%90%9C%20%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.JPG&quot; alt=&quot;등록된 이벤트 보기&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;등록된 이벤트를 삭제하려면 다음 명령어로 삭제할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼 20,000 👋&lt;/p&gt;</content><author><name>전지호</name></author><category term="aws" /><category term="sql" /><category term="mysql" /><summary type="html">AWS에서 사용하는 RDB 데이터베이스인 AuroraDB에서 스케줄러를 사용하는 방법을 설명합니다. 굉장히 많은 데이터가 일반 RDB에 쌓일 경우, 불가피하게 속도에 영향을 끼칠 수 있습니다. 한 예로, 1 번의 쿼리로 데이터를 삭제하기 너무 많은 시간이 필요할 수 있습니다. 스케줄러를 적절히 사용하면 데이터 관리를 용이하게 할 수 있을 것입니다.</summary></entry><entry><title type="html">Spark broadcasting을 이용해 기존 머신러닝 라이브러리 속도 개선하기</title><link href="http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98.html" rel="alternate" type="text/html" title="Spark broadcasting을 이용해 기존 머신러닝 라이브러리 속도 개선하기" /><published>2021-05-31T10:00:00-05:00</published><updated>2021-05-31T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98.html">&lt;h1 id=&quot;spark-broadcast&quot;&gt;Spark Broadcast&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리에게 필요한 것은 inference 효율성 😎&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;기존 python ml 라이브러리로 다량의 데이터를 빠르게 처리를 해야 할 때!  &lt;u&gt;Spark broadcasting&lt;/u&gt;을 이용해 inference 속도를 개선할 수 있습니다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spark의-공유-변수&quot;&gt;Spark의 공유 변수&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아피치 스파크&lt;/code&gt;는 SQL, 머신러닝 등 처리를 위한 기본 제공 모듈이 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대규모 데이터 처리용 통합 분석 엔진&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
일반적인 스파크 연산이 클러스터에서 실행될 때 함수에서 사용되는 변수는 각 클러스터에 복제되고 각 노드 연산에서는 독립적입니다. 클러스터 상에서 변수를 공유하는 것은 비효율적이기 때문인데, 일반적인 연산 패턴을 지원하기 위해 아래와 같은 공유 변수를 제공합니다
.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;broadcast variables : 큰 데이터를 효율적으로 처리하는데 사용&lt;/li&gt;
  &lt;li&gt;Accumulators variables : 특정 컬렉션의 정보를 집계하는 데 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;broadcast variables&lt;/code&gt;에 대하여 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spark-broadcast-란&quot;&gt;Spark broadcast 란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;broadcast 변수는 읽기 전용 변수입니다. 모든 노드에 큰 input 데이터셋을 제공할 때 효과적인 방법이라고 할 수 있습니다. 이를 사용하면 효율적인 broadcast 알고리즘을 통해 계산 비용을 줄일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;스파크의 액션들은 기본적으로 여러 단계의 집합으로 실행되는데, 자동적으로 각 단계에 필요한 공유 변수들을 broadcast하는 것입니다.&lt;/p&gt;

&lt;p&gt;Broadcast 변수는 RDD나 Dataframe과 동일한 방식으로 사용될 수 있습니다. (데이터는 serialized 캐싱되고 deserialized 되어 각 테스크로 넘어가게 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
호출 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sc &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; SparkContext&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
var &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Array&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4,5,6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 사용할 공유 변수 var&lt;/span&gt;

broadcastvar &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;일단 broadcast variable이 만들어지면, 클러스터상의 모든 함수에 사용될 수 있습니다. (즉, &lt;b&gt;&lt;u&gt;var은 한 번 이상 노드에 올라가지 않게&lt;/u&gt;&lt;/b&gt; 됩니다.)&lt;/p&gt;

&lt;p&gt;참고로, 한 번 생성된 broadcastvar 객체는 이후 수정될 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
broadcast 된 값을 이용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value 메소드&lt;/code&gt;를 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# value 값에 액세스 하기 위함&lt;/span&gt;
broadcastvar.value

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Array&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4,5,6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sklearn에-spark-broadcast를-적용해-inference-하기&quot;&gt;sklearn에 spark broadcast를 적용해 inference 하기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;python에서 가장 많이 이용되는 mechine learning library는 sklearn일 것입니다. sklearn 에서는 보통 pandas dataframe 을 활용한 데이터를 fit하고 predict 하게 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, KNN (K-Nearest Neighbors)과 같은 알고리즘을 사용하게 된다면 우리는 각 key 값에 대한 각각의 k개의 neighbors를 모두 구해야합니다. 즉, &lt;b&gt;&lt;u&gt;key 값 하나하나에 모든 데이터를 연산&lt;/u&gt;&lt;/b&gt;하게 됩니다.결국 inference 시간이 엄청나게 길어질 수 밖에 없는 구조가 됩니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;b&gt;&lt;u&gt;sklearn model을 broadcast 하는 방식&lt;/u&gt;&lt;/b&gt;을 활용해 효율적으로 처리될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제 코드는 다음과 같습니다. ( knn model 사용 )&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def knn_regressor_broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_pd, &lt;span class=&quot;nv&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;100, &lt;span class=&quot;nv&quot;&gt;n_partitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10, weights &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;uniform&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

  &lt;span class=&quot;c&quot;&gt;# X_train, y_train, X_test, y_test 의 경우 pandas dataframe 형태&lt;/span&gt;
  

  &lt;span class=&quot;c&quot;&gt;# 모델 fit&lt;/span&gt;
  knn &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; KNeighborsRegressor&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;n_neighbors &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; neighbors, weights &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; weights&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; knn.fit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;X_train, y_train&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  
  &lt;span class=&quot;c&quot;&gt;# 여러 배치로 돌리기 위한 함수&lt;/span&gt;
  def batch&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
    yield list&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    
  rdd &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.parallelize&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;X_test, n_partitions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.zipWithIndex&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  b_model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;model&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rdd.mapPartitions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;batch&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.map&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lambda value: &lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;x[0] &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;value], &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;x[1] &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;value]&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;.flatMap&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lambda x: zip&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x[1], b_model.value.predict&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x[0]&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
  
  result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; result.collect&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 &lt;b&gt;model을 broadcast + rdd test data&lt;/b&gt;를 사용하자 Pandas dataframe을 이용해 predict를 하였을 때 Runtime errorrk가 났던 모델을 약 5분 내외로 처리할 수 있었습니다 👏👏&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;부가적인 코드 설명을 잠시 하자면&lt;/p&gt;

&lt;p&gt;mapPartitions의 경우 나눠진 partition내에서 연산을 수행하게 해줍니다&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rdd &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.parallelize&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;1, 2, 3, 4], 2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
def f&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: yield &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
rdd.mapPartitions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.collect&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3, 7]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;즉, broadcast된 모델에 test 데이터를 batch  형태로 분산 처리가 가능해진다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://www.tutorialspoint.com/apache_spark/advanced_spark_programming.htm&quot;&gt;About advaced spark programming - spark broadcast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://sparkbyexamples.com/spark/spark-broadcast-variables/&quot;&gt;Spark Broadcast Varibales&lt;/a&gt;&lt;/p&gt;</content><author><name>김연수</name></author><category term="python" /><category term="sklearn" /><category term="ml" /><category term="spark" /><summary type="html">좀 더 빠른 ML inference를 위해 spark broadcasting을 사용해봅니다.</summary></entry><entry><title type="html">AWS EKS 쿠버네티스에서 JupyterHub 환경 설정하기</title><link href="http://0.0.0.0:4000/2021/05/30/JupyterhubConfig-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS EKS 쿠버네티스에서 JupyterHub 환경 설정하기" /><published>2021-05-30T10:00:00-05:00</published><updated>2021-05-30T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/30/JupyterhubConfig-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/30/JupyterhubConfig-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;쿠버네티스-jupyterhub-설정법-&quot;&gt;쿠버네티스 JupyterHub 설정법 👨‍💻&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;config.yaml을 이용한 사용자 별 환경 구성법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;첫-번째-configyaml이-작업-폴더에-있는지-확인해-주세요&quot;&gt;첫 번째, config.yaml이 작업 폴더에 있는지 확인해 주세요.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;👉 &lt;a href=&quot;/2021/05/27/JupyterhubForK8S-전지호.html&quot;&gt;첫번째포스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 포스트 처음에 만들었던 config.yaml를 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/config%EC%9C%84%EC%B9%98.JPG&quot; alt=&quot;config.yaml 위치&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;config.yaml을 수정하고 다음 명령어를 입력하면 변경사항이 jupyterhub에 적용됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm upgrade &lt;span class=&quot;nt&quot;&gt;--cleanup-on-fail&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt; jhub &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; jhub &lt;span class=&quot;nt&quot;&gt;--values&lt;/span&gt; config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;두-번째-기본으로-사용되는-jupyter-이미지를-사양에-맡게-변경해봅시다&quot;&gt;두 번째, 기본으로 사용되는 jupyter 이미지를 사양에 맡게 변경해봅시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;다음과 같이 config.yaml을 수정하면 기본 도커이미지가 jupyter/datascience-notebook로 변경됩니다.&lt;/p&gt;

&lt;p&gt;사무실 환경에 맡게 커스텀한 도커이미지를 도커허브에 푸쉬한 뒤 그것을 사용해도 무방합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# You should replace the &quot;latest&quot; tag with a fixed version from:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# https://hub.docker.com/r/jupyter/datascience-notebook/tags/&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# Inspect the Dockerfile at:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# https://github.com/jupyter/docker-stacks/tree/HEAD/datascience-notebook/Dockerfile&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/datascience-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세-번째-jupyterlab을-기본으로-사용해봅시다&quot;&gt;세 번째, jupyterlab을 기본으로 사용해봅시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;defaultUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/lab&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%A3%BC%ED%94%BC%ED%84%B0%EB%9E%A9.JPG&quot; alt=&quot;주피터랩&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;네-번째-다양한-주피터-이미지를-선택할-수-있게-합시다&quot;&gt;네 번째, 다양한 주피터 이미지를 선택할 수 있게 합시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;profileList에 항목을 추가하면 로그인 시 이미지를 선택하여 jupyter를 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래 예는 pyspark버전과 datascience버전을 선택할 수 있는 예제입니다.&lt;/p&gt;

&lt;p&gt;선택하지 않으면, jupyter/minimal-notebook이 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;defaultUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/lab&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/minimal-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;profileList&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pyspark&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;spark를&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;사용할&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;수&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;일반&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/pyspark-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow가&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설치되어&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/tensorflow-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;7a0c7325e470&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%A3%BC%ED%94%BC%ED%84%B0%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%84%A0%ED%83%9D.JPG&quot; alt=&quot;원하는 주피터로 시작&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다섯-번째-사용자와-비밀번호를-설정하는-방법&quot;&gt;다섯 번째, 사용자와 비밀번호를 설정하는 방법&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;아래와 같이 입력하면 2명의 관리자 유저, 2명의 일반 유저, 공통 비밀번호로 접근할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;hub&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;Authenticator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;admin_users&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;admin&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;batteryho&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;allowed_users&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;seungjin&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ehdud8565&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;yeonsuuu&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;sanghyunbaek&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;hgchoi16&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;DummyAuthenticator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;비밀번호입력&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;JupyterHub&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;authenticator_class&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dummy&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 생략&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;리소스를-설정하는-방법&quot;&gt;리소스를 설정하는 방법&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;쿠버네티스내에 jupyter notebook들은 기본적으로 각 사용자에게는 1G의 RAM 이 보장 됩니다. 모든 사용자는 1G 이상을 가지고 있지만 가능한 경우 기술적으로 더 많이 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하여 메모리 제한을 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;guarantee는 필요에 의해 남아있는 다른 리소스를 사용하는 것을 의미하고,&lt;/p&gt;

&lt;p&gt;limit는 더이상 리소스를 사용하지 못함을 의미 합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2G&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;guarantee&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1G&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cpu의 제한 또한 다음과 같이 변경할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;.5&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;guarantee&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;.5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gpu-할당하는-방법&quot;&gt;GPU 할당하는 방법&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;tensorflow나 pytorch같은 딥러닝 프레임워크들은 GPU를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하여 gpu 할당이 가능합니다.&lt;/p&gt;

&lt;p&gt;물론, 쿠버네티스 환경에 gpu가 있어야합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;defaultUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/lab&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/minimal-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;profileList&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pyspark&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;spark를&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;사용할&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;수&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;일반&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/pyspark-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow가&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설치되어&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/tensorflow-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;7a0c7325e470&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 해당부분&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;extra_resource_limits&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;nvidia.com/gpu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본적인 사용방법을 알아봤습니다.&lt;/p&gt;

&lt;p&gt;더 많은 정보는 아래 링크에서 확인해주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h2&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://zero-to-jupyterhub.readthedocs.io/en/latest/kubernetes/setup-kubernetes.html&quot;&gt;zero-to-jupyterhub-on-k8s&lt;/a&gt;&lt;/p&gt;</content><author><name>전지호</name></author><category term="docker" /><category term="kubernetes" /><category term="jupyter" /><category term="aws" /><summary type="html">JupyterHub를 구축했다면 사용자 별 환경과 리소스를 구분하기 위한 설정방법을 알아봅시다.</summary></entry><entry><title type="html">AWS EKS 쿠버네티스에서 JupyterHub 설치하기</title><link href="http://0.0.0.0:4000/2021/05/27/JupyterhubForK8S-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS EKS 쿠버네티스에서 JupyterHub 설치하기" /><published>2021-05-27T10:00:00-05:00</published><updated>2021-05-27T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/27/JupyterhubForK8S-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/27/JupyterhubForK8S-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;쿠버네티스에-jupyterhub-설치-&quot;&gt;쿠버네티스에 JupyterHub 설치 👨‍💻&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;쿠버네티스가 구축되어 있다면, helm 차트를 이용하여 간단하게 JupyterHub를 설치할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;일단 작업환경을 수행할 폴더를 만들고 해당 폴더안에서 작업을 수행합니다.&lt;/p&gt;

&lt;p&gt;해당 폴더는 JupyterHub의 앞으로의 configration을 담당할 폴더입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;첫-번째-helm-repogitory-업데이트&quot;&gt;첫 번째, helm repogitory 업데이트&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;쿠버네티스 환경에 연결되어 있고, helm이 설치되어 있다면 다음의 명령어로 차트를 설치할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm repo add jupyterhub https://jupyterhub.github.io/helm-chart/
helm repo update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같은 출력이 보여야합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hang tight &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;we grab the latest from your chart repositories...
...Skip &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;chart repository
...Successfully got an update from the &lt;span class=&quot;s2&quot;&gt;&quot;stable&quot;&lt;/span&gt; chart repository
...Successfully got an update from the &lt;span class=&quot;s2&quot;&gt;&quot;jupyterhub&quot;&lt;/span&gt; chart repository
Update Complete. ⎈ Happy Helming!⎈
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;두-번째-jupyterhub-차트-다운로드&quot;&gt;두 번째, JupyterHub 차트 다운로드&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;차트를 바로 설치하기 보단 템플릿의 구성을 확인하고 설치하기 위해 차트를 다운로드합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm fetch jupyterhub/jupyterhub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다운로드가 완료되면 압축된 차트 파일이 보입니다. 압축을 해제합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-zxvf&lt;/span&gt; .&lt;span class=&quot;se&quot;&gt;\&amp;lt;&lt;/span&gt;다운로드된파일&amp;gt;.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/jhubdir.JPG&quot; alt=&quot;주피터허브 폴더구조&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세-번째-템플릿을-변경할-수-있는-구성-파일을-만들어-봅시다&quot;&gt;세 번째, 템플릿을 변경할 수 있는 구성 파일을 만들어 봅시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;helm 차트 리소스에 기본적으로 설치할 구성요소에 대한 리소스가 모두 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 config.yaml 파일을 이용하면 구성요서에 대한 템플릿의 변경이 가능합니다.&lt;/p&gt;

&lt;p&gt;그렇기때문에, config.yaml을 만들어 참조하고 설정을 변경해봅시다.&lt;/p&gt;

&lt;p&gt;아래와 같이 빈 config.yaml을 만들어 작업 폴더 밑 차트 폴더에에 추가해주세요.(Chart.yaml과 같은 위치)&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# This file can update the JupyterHub Helm chart's default configuration values.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# For reference see the configuration reference and default values, but make&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# sure to refer to the Helm chart version of interest to you!&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Introduction to YAML:     https://www.youtube.com/watch?v=cdLNKUoMc6c&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Chart config reference:   https://zero-to-jupyterhub.readthedocs.io/en/stable/resources/reference.html&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Chart default values:     https://github.com/jupyterhub/zero-to-jupyterhub-k8s/blob/HEAD/jupyterhub/values.yaml&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Available chart versions: https://jupyterhub.github.io/helm-chart/&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;네-번째-차트를-쿠버네티스-환경에-배포하여-설치해봅시다&quot;&gt;네 번째, 차트를 쿠버네티스 환경에 배포하여 설치해봅시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;차트 폴더에서 아래의 명령어를 입력해주세요.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm upgrade &lt;span class=&quot;nt&quot;&gt;--cleanup-on-fail&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt; jhub &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; jhub &lt;span class=&quot;nt&quot;&gt;--create-namespace&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--values&lt;/span&gt; config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;🤬🤬🤬&lt;/p&gt;

&lt;p&gt;아래와 같은 에러가 있다면, 배포환경에 토큰이 꼭 필요하단 이야기입니다.(예시: AWS EKS)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/tokenerror.JPG&quot; alt=&quot;토큰필요&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Openssl이나 여타 다른 토큰 제네레이터 프로그램을 이용하여 32자리의 hex코드를 임의로 생성해주세요.&lt;/p&gt;

&lt;p&gt;폴더 안 values.yaml 파일에 시크릿 토큰을 입력하는 곳이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/requiredtokken.JPG&quot; alt=&quot;토큰넣기&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;시크릿 토큰 입력&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/requiredtokkensuccess.JPG&quot; alt=&quot;토큰성공&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다시 명령어를 입력해주세요.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm upgrade &lt;span class=&quot;nt&quot;&gt;--cleanup-on-fail&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt; jhub &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; jhub &lt;span class=&quot;nt&quot;&gt;--create-namespace&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--values&lt;/span&gt; config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;인스톨이 성공했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/installsuccess.JPG&quot; alt=&quot;주피터허브인스톨&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pod가 모두 잘 돌아갑니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get pod &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; jhub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/pods.JPG&quot; alt=&quot;주피터허브파드&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;외부접속을 위한 서비스도 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get svc &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; jhub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/svc.JPG&quot; alt=&quot;주피터허브서비스&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다섯-번째-jupyterhub-접속하기&quot;&gt;다섯 번째, JupyterHub 접속하기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;서비스에 나온 퍼블릭 주소로 접근해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/connectsuccess.JPG&quot; alt=&quot;외부접속&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스에 설치된 주피터 허브에 접속이 가능합니다!!(로드밸런서 설정은 따로 해주세요.)&lt;/p&gt;

&lt;p&gt;아무 아이디로 로그인을 해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;로그인 후에 사용자별 서버가 생성되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/servercreate.JPG&quot; alt=&quot;서버생성&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;주피터 노트북이 떳습니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/jupyterhub.JPG&quot; alt=&quot;주피터허브&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 명령어를 입력해보면,&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get pod &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; jhub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/userpod.JPG&quot; alt=&quot;유저별파드&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유저별로 Pod가 생성된 유연한 환경 분리가 가능한 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;마지막-jupyterhub-삭제&quot;&gt;마지막, JupyterHub 삭제&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;JupyterHub를 삭제하려면 간단하게 다음 명령어를 입력하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm uninstall jhub &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; jhub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;가능한-것들&quot;&gt;가능한 것들&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;JupyterHub를 쿠버네티스 환경에 구축하므로서 생각했던 두 가지 목표가 가능해졌습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 별 다른 주피터 노트북 환경 구성 (pyspark-notebook, datascience-notebook)&lt;/li&gt;
  &lt;li&gt;사용자 별 GPU 점유 주피터 노트북 (pyspark-notebook, datascience-notebook)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 포스트에서는 config.yaml을 수정하여 위와 같은 활동을 다뤄보겠습니다.&lt;/p&gt;

&lt;p&gt;🖐🖐🖐&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h2&gt;
&lt;p&gt;👉 &lt;a href=&quot;https://zero-to-jupyterhub.readthedocs.io/en/latest/jupyterhub/installation.html#install-jupyterhub&quot;&gt;zero-to-jupyterhub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://zero-to-jupyterhub.readthedocs.io/en/latest/kubernetes/setup-kubernetes.html&quot;&gt;zero-to-jupyterhub-on-k8s&lt;/a&gt;&lt;/p&gt;</content><author><name>전지호</name></author><category term="docker" /><category term="kubernetes" /><category term="jupyter" /><category term="aws" /><summary type="html">쿠버네티스에 여러명의 분석가가 함께 작업할 수 있는 JupyterHub를 구축해보십니다. 각자 분리된 환경에서 일할 수 있으면 참 좋겠죠?</summary></entry><entry><title type="html">Facial Expression 기반의 게임 경험 평가</title><link href="http://0.0.0.0:4000/2021/05/25/FacialExpression%EA%B8%B0%EB%B0%98%EA%B2%8C%EC%9E%84%EA%B2%BD%ED%97%98%ED%8F%89%EA%B0%80-%EA%B6%8C%EC%8A%B9%EC%A7%84.html" rel="alternate" type="text/html" title="Facial Expression 기반의 게임 경험 평가" /><published>2021-05-25T10:00:00-05:00</published><updated>2021-05-25T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/25/FacialExpression%EA%B8%B0%EB%B0%98%EA%B2%8C%EC%9E%84%EA%B2%BD%ED%97%98%ED%8F%89%EA%B0%80-%EA%B6%8C%EC%8A%B9%EC%A7%84</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/25/FacialExpression%EA%B8%B0%EB%B0%98%EA%B2%8C%EC%9E%84%EA%B2%BD%ED%97%98%ED%8F%89%EA%B0%80-%EA%B6%8C%EC%8A%B9%EC%A7%84.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;최근 저희가 만든 nxFGT 얼굴 분석 엔진을 이용한 테스트가 진행되었습니다. &lt;br /&gt;
가장 큰 목적은 게임을 플레이하면서 게임 테스터는 어떤 감정들을 얼굴로 표현할까? 에 초점을 맞춰진 테스트입니다. 그 감정의 변화가 일어나는 특별한 순간들을 캐치하고, 분석하는 것이 이 프로젝트의 목적입니다.&lt;br /&gt;
이 테스트는 다음과 같은 15개의 게임 세션으로 구성되었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;세션수&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;플레이타임&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FIFA Online 4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 25분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;플레이투게더&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 35분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;It takes two&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 82분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;타이탄폴2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 35분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;서든어택&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 12분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;클래시로얄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 4분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ALTF4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 8분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;오버워치&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 8분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;리그 오브 레전드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 22분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;던전 앤 파이터&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 10분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;카트라이더&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;29&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 77분&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;카운팅&quot;&gt;카운팅&lt;/h2&gt;
&lt;p&gt;기본적으로 사람이 컴퓨터 앞에 앉았을 때는 무표정입니다. 그리고 게임 속 어떤 변화가 일어날때마다 사람은 웃거나, 화를 내거나 하는 특별한 감정이 얼굴로 나타납니다.
집계된 감정을 카운트로 보면 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;세션수&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;플레이타임&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;긍정반응&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;부정반응&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FIFA Online 4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 25분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;플레이투게더&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 35분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;It takes two&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 82분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3980&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;75&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;타이탄폴2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 35분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;서든어택&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 12분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;135&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;클래시로얄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 4분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ALTF4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 8분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;오버워치&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 8분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;리그 오브 레전드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 22분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;던전 앤 파이터&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 10분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;95&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;카트라이더&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;29&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;약 77분&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3770&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Stacked Bar Chart로 본 표입니다.
&lt;img src=&quot;https://solution-userstats.s3.amazonaws.com/techblogs/seungjin/2021-05-26-FE/1.png&quot; alt=&quot;Stacked Bar Chart&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플레이타임이 긴 It takes two, 카트라이더를 빼고 본 표입니다.
&lt;img src=&quot;https://solution-userstats.s3.amazonaws.com/techblogs/seungjin/2021-05-26-FE/2.png&quot; alt=&quot;Stacked Bar Chart2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 통해 감정의 발생량과 각각 긍정, 부정량을 파악할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;카트라이더-감정-발생-비율&quot;&gt;카트라이더 감정 발생 비율&lt;/h2&gt;
&lt;p&gt;카트라이더의 경우가 장르 특성상 가장 다양한 감정이 발생했기 때문에 각각 감정의 발생량을 비율로 표현해봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.amazonaws.com/techblogs/seungjin/2021-05-26-FE/3.png&quot; alt=&quot;Stacked Bar Chart2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세션별-시계열-누적&quot;&gt;세션별 시계열 누적&lt;/h2&gt;
&lt;p&gt;게임 세션에서 시간이 흐름에 따라 감정량이 어떻게 누적되어가는지를 추적하는 그래프입니다.
세션의 초반, 중반, 후반 중 어디서 집중적으로 테스트 참가자의 감정 변화가 발생했는지 알 수 있습니다.&lt;br /&gt;
&lt;img src=&quot;https://solution-userstats.s3.amazonaws.com/techblogs/seungjin/2021-05-26-FE/4.png&quot; alt=&quot;Acc Chart&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;대표-감정&quot;&gt;대표 감정&lt;/h2&gt;
&lt;p&gt;특정 게임마다 많이 일어나는 감정이 각각 다른지를 분석해봤습니다. 현재는 테스트라 숫자가 적지만, 차후 대량 플레이 데이터 삽입 시 특정 게임마다, 특정 게임의 구간마다 대표 반응을 알 수 있는 메트릭이 될 것입니다. 
현재는 게임 타이틀로 구분하여 나타냈습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;대표 반응&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FIFA Online 4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;플레이투게더&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;It takes two&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;타이탄폴2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;서든어택&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;클래시로얄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;무표정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ALTF4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;화남&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;오버워치&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;무표정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;리그 오브 레전드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;던전 앤 파이터&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;카트라이더&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;웃음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ALTF4의 경우가 특이한데, 실제로 유저를 열받게 하면서 몰입하게 만든다는 평가를 받는 게임입니다. 육안 분석결과도 해당 플레이동안 테스트 참가자가 자주 화내는 모습을 관찰할 수 있었습니다.
참조:&lt;a href=&quot;https://namu.wiki/w/ALTF4&quot;&gt;나무위키 ALTF4&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;이번 테스트로 게임 테스트 시 얼굴에서 발생하는 감정을 어떤 식으로 가공할 것인지에 대해 많은 고민을 해볼 수 있었습니다. 적은 량이지만 게임의 특성과 사용자의 감정 반응의 연관성을 발견할 수도 있었습니다. 현재는 게임을 카테고리로 묶어서 결과를 냈지만 테스트 세션의 수가 늘어날수록, 각 게임에서도 세부 구간별로 특성을 정의하여 결과를 도출할수 있다고 생각됩니다.&lt;/p&gt;</content><author><name>권승진</name></author><category term="computervision" /><category term="facialexpressionrecognition" /><summary type="html">Facial Expression 기반의 게임 경험 평가</summary></entry><entry><title type="html">AWS DynamoDB 연동하기</title><link href="http://0.0.0.0:4000/2021/05/16/DynamoDB-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS DynamoDB 연동하기" /><published>2021-05-16T10:00:00-05:00</published><updated>2021-05-16T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/16/DynamoDB-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/16/DynamoDB-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;python으로-aws-dynamodb-연동하기&quot;&gt;Python으로 AWS DynamoDB 연동하기&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Python을 사용하여 AWS DynamoDB 데이터 쿼리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;boto3-설치&quot;&gt;boto3 설치&lt;/h2&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boto3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치된 python 패키지 매니저로 boto3를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;boto3client-사용&quot;&gt;boto3.client 사용&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dynamodb = boto3.client('dynamodb', aws_access_key_id='본인의 Access ID', aws_secret_access_key='본인의 Secret Access Key', region_name='리전 입력')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;boto3로 dynamoDB에 접근하는 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boto3.resource&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boto3.client&lt;/code&gt; 두 가지 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boto3.resource&lt;/code&gt;의 방식이 AWS의 공식 문서에 샘플로 등장하지만, 사용이 좀 더 간편한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boto3.client&lt;/code&gt; 방식을 소개하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;parameter-설정&quot;&gt;Parameter 설정&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;dynamoDB를 사용할 때는 각 row의 column에 해당하는 type을 명시해야 데이터 조작이 가능합니다.&lt;/p&gt;

&lt;p&gt;자주 사용하는 type은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S: 문자열
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;S&quot;: &quot;Hello&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;N: 문자열
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;N&quot;: &quot;11.0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SS: 문자열 리스트
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;SS&quot;: [ &quot;Hello&quot;, &quot;Jiho&quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;NS: 숫자 문자열 리스트
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;NS&quot;: [ &quot;11.0&quot;, &quot;123.45&quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;M: key-value 형태의 Map
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;M&quot;: {&quot;Name&quot;: {&quot;S&quot;: &quot;Joe&quot;}, &quot;Age&quot;: {&quot;N&quot;: &quot;35&quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;L: 다양한 타입의 List
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;L&quot;: [ {&quot;S&quot;: &quot;Hello&quot;}, {&quot;S&quot;: &quot;Hello&quot;}, {&quot;S&quot;: &quot;Hello&quot;} ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;insert&quot;&gt;Insert&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;response = dynamodb.put_item(
    TableName='테이블 명', 
    Item={ 
            'column1':{ 
                'S': 'value1' 
            }, 
            'column2':{
                'S': 'value2' 
            }
        }
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;select&quot;&gt;Select&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;response = dynamodb.get_item(
    TableName='string',
    Key={
            'column1':{ 
                'S': 'value1'
            }
        }
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>전지호</name></author><category term="aws" /><category term="python" /><summary type="html">AWS에서 사용하는 대표적인 NoSQL 데이터베이스인 DynamoDB의 데이터를 Python을 사용하여 가져오는 것을 알아봅시다.</summary></entry></feed>