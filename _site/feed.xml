<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2021-06-08T22:29:25-05:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">머신러닝파트 기술블로그</title><subtitle></subtitle><entry><title type="html">2021년 6월 머신러닝파트 월간 리뷰</title><link href="http://0.0.0.0:4000/2021/06/04/MonthlyReport202106-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="2021년 6월 머신러닝파트 월간 리뷰" /><published>2021-06-04T10:00:00-05:00</published><updated>2021-06-04T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/04/MonthlyReport202106-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/04/MonthlyReport202106-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;과금넛지&quot;&gt;과금넛지&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;4차 실험 집행 후, 넛지 대상자의 반응 여부를 판단하기 위해 충전액 예측 모델링을 진행 중입니다.&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;u&gt;넛지 전후 충전액을 예측&lt;/u&gt;하여 유저의 반응 여부와 효과를 측정하기 위함입니다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;4월 리뷰 당시보다 효율적인 효과측정을 위해, 더 고도화된 모델링이 필요하다고 판단했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1차-충전액-예측-모델링의-과정&quot;&gt;1차 충전액 예측 모델링의 과정&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;1차에서 4차까지의 실험 결과와 Nxlog를 바탕으로 Feature를 만들어 여러가지 예측 모델에 집어넣어 성능을 평가했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;feature-extraction&quot;&gt;Feature Extraction&lt;/h3&gt;

&lt;p&gt;충전액을 예측할 수 있는 Feature를 분류별로 추출해보았습니다.&lt;/p&gt;

&lt;p&gt;첫 번째, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;접속, 충전, 구매&lt;/code&gt;와 관련한 Features입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;접속횟수, 플레이타임, 미접속일수 등 접속 관련 세부 정보&lt;/li&gt;
  &lt;li&gt;구매횟수, 구매액 등 구매 관련 세부 정보&lt;/li&gt;
  &lt;li&gt;충전횟수, 충전액 등 충전 관련 세부 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 번째, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인구 통계&lt;/code&gt;와 관련한 Features입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성별, 나이&lt;/li&gt;
  &lt;li&gt;아이템 관련
    &lt;ul&gt;
      &lt;li&gt;PCA 기반 아이템 그룹 구매 count
        &lt;ul&gt;
          &lt;li&gt;(상위 100개 아이템 기준) 유저 아이템 메트릭스를 이용해 PCA로 item 그룹 생성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;유저별 아이템 구매 경험 및 가격
        &lt;ul&gt;
          &lt;li&gt;아이템 평균 가격, 평균 구매 가격, main 아이템 구매 여부 및 수량, 고가치 아이템 구매 여부 및 수량&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시샵 방문 관련
    &lt;ul&gt;
      &lt;li&gt;과거 방문횟수, 방문일수 등 관련 세부 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;model-fitting&quot;&gt;Model Fitting&lt;/h3&gt;

&lt;p&gt;목적&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(실험군 유저가 넛지를 받지 않았을 때의) 30일간의 충전량 예측&lt;/li&gt;
  &lt;li&gt;실제로는 실험군 유저 모두가 넛지를 받았으므로, 일어나지 않은 일(counterfactuals)에 대한 예측&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용 데이터&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모델링 과정의 데이터는 대조군만을 사용 (넛지에 오염되지 않은 실험대상)&lt;/li&gt;
  &lt;li&gt;초반 과금량 분포를 보고, 전체 유저의 10퍼센트 정도의 상위 outlier 제거
    &lt;ul&gt;
      &lt;li&gt;outlier로 인해 오차가 커지는 것을 방지&lt;/li&gt;
      &lt;li&gt;전반적으로 과소추정하는 모델을 만들기 위함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;lightGBM&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;binary
    &lt;ul&gt;
      &lt;li&gt;약 75만 유저 중 46만이 무과금 유저로, 대부분 0(무과금)으로 예측하는 문제 발생&lt;/li&gt;
      &lt;li&gt;binary model로 무과금 유저를 걸러낸 후, regression model을 사용하여 오차를 줄이면서 동시에 납득할만한 예측치를 얻고자 함&lt;/li&gt;
      &lt;li&gt;보수적인 예측을 위해 label 1 (실제 과금 유저)에 대한 recall (실제 과금 유저를 과금으로 예측하는 것)을 스코어로 사용
        &lt;ul&gt;
          &lt;li&gt;이를 통해, 과금 가능성이 조금이라도 보이는 유저는 걸러지지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;label 1에 대한 recall 0.9, 0에 대한 recall 0.5 전후를 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;regression
    &lt;ul&gt;
      &lt;li&gt;MAPE 최소화 LightGBM 회귀 모델
        &lt;ul&gt;
          &lt;li&gt;모델 예측값이 대부분 0인 문제를 보임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MSE 최소화 LightGBM 회귀 모델
        &lt;ul&gt;
          &lt;li&gt;과금이 높은 유저에 대한 오차 패널티를 증대하여, 모델 예측값이 대부분 0인 문제를 완화하려는 시도&lt;/li&gt;
          &lt;li&gt;MAPE 최소화 LightGBM 회귀 모델에 비해 과금량이 많은 유저에 대한 오차가 상대적으로 작지만, 여전히 대부분 예측값이 0인 문제 잔재&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;binary 분류 → MAPE &amp;amp; MSE 최소화 LightGBM 회귀 모델
        &lt;ul&gt;
          &lt;li&gt;모델의 예측값이 대부분 0인 문제를 해결하기 위해, binary 분류 모델이 과금 유저라고 예측한 데이터만 사용하여 모델 트레이닝&lt;/li&gt;
          &lt;li&gt;분류 모델이 과금 유저라고 예측한 유저의 약 50%는 무과금 유저였고, 예측된 과금량은 여전히 대부분 0으로 예측&lt;/li&gt;
          &lt;li&gt;백분률 변환과 log 변환을 시도하였으나 큰 변화 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;KNN&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Base model을 위한 KNN
    &lt;ul&gt;
      &lt;li&gt;기존 모델과의 성능 비교를 위한 모델&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과금 여부 예측 이진 분류 LightGBM 모델 → KNN 회귀 모델
    &lt;ul&gt;
      &lt;li&gt;과금 여부 예측 이진 분류 모델이 1(과금 유저)로 예측한 데이터에 한해서 KNN 회귀 모델 적용&lt;/li&gt;
      &lt;li&gt;여전히 예측값이 0에 가까운 문제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;다음과 같은 성능을 보였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Model&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;alias&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;MAE&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;MAPE (+1000후 계산)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Baseline KNN&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;base_knn_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15960원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;671.80%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MAPE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mape_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;14694원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;27.88%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;16035원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;688.66%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → MAPE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_mape_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;14582원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;54.01%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;13799원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;485.77%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → Log 변환 후  MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_log_mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15003원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;44.52%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → 백분률 변환 후 MSE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_minmax_mse_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;13450원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;469.54%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → 백분률 변환 후 MAE 최소화 LightGBM 회귀 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_minmax_mae_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12056원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;177.27%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;과금 여부 예측 이진 분류 LightGBM 모델 → KNN 회귀모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bin_knn_model&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;14971원&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;556.93%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/yeonsuuu/y_pred_error1.png&quot; alt=&quot;오차 그래프 1&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/yeonsuuu/y_pred_error2.png&quot; alt=&quot;오차 그래프 2&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1차-충전액-예측-모델링의-결론&quot;&gt;1차 충전액 예측 모델링의 결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;5차 실험을 진행하기에, 1차 충전액 예측 모델링은 &lt;u&gt;충분하지 못한 성능&lt;/u&gt;이 나왔습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대부분의 값을 0의로 예측했고, 충전여부를 예측하는 분류모델도 제대로 작동하지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;모델 성능에 문제가 있었던 이유는 아래의 3가지 중 하나로 가정하고 있습니다. (+Cashflow 데이터)&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 : 모델에 충분한 정보를 주지 않음
    &lt;ul&gt;
      &lt;li&gt;추가 feature 생성 진행중
        &lt;ul&gt;
          &lt;li&gt;개별 게임에 종속된 정보&lt;/li&gt;
          &lt;li&gt;cashflow에서 얻을 수 있는 정보&lt;/li&gt;
          &lt;li&gt;시계열 모델 예측결과 및 embedding&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2 : 관찰기간인 30일 간, 발생하는 외부 이벤트가 유저 구매행동에 영향을 줌
    &lt;ul&gt;
      &lt;li&gt;구매 행동에 영향을 줄 수 있는 외부 이벤트: 이탈, 게임 내 여론 변화, 확률형 아이템의 사용결과(운) 등등&lt;/li&gt;
      &lt;li&gt;모델에 가능한 한 많은 정보를 제공했음에도 스코어가 개선되지 않을 때 의심할 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3 : 유저의 구매행동이 충동적으로 일어나므로 유의미한 범위 내의 예측이 불가
    &lt;ul&gt;
      &lt;li&gt;&lt;u&gt;&lt;b&gt;위의 모든 가능성을 다 탐색했음에도 모델 성능이 충분히 나오지 않을 경우, 예측이 불가능한 것으로 간주할 예정&lt;/b&gt;&lt;/u&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cashflow의 데이터의 이상&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Cashflow의 데이터의 이상이 있었지만, 해결완료.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cashflow-데이터-eda&quot;&gt;Cashflow 데이터 EDA&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;u&gt;구매액은 증가했으나, 충전액의 변화 없다&lt;/u&gt;는 것이 확인되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;cashflow EDA 결과에 대한 그림이 들어가는 곳 (도영 추가예정 (통계값과 그림))&lt;/p&gt;

&lt;p&gt;구체적으로 다음과 같은 특징을 확인할 수 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무료캐시 지급 후 72시간 내에 다수(구매유저 중 60%)의 유저가 무료캐시 사용&lt;/li&gt;
  &lt;li&gt;무료캐시 사용시 추가 유료충전 빈도는 비교군에서 자연발생하는 유료충전과 같은 빈도를 보임
    &lt;ul&gt;
      &lt;li&gt;잔액이 없을 경우, 지급받은 무료캐시로 구매가능한 정도의 아이템을 구매&lt;/li&gt;
      &lt;li&gt;잔액이 있을 경우, 지급받은 무료캐시와 잔액을 활용하여 아이템을 구매&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무료캐시를 사용한 구매를 제외하면 충전 및 구매 양상에 변화 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;과금넛지-6월-계획&quot;&gt;과금넛지 6월 계획&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;과금넛지 프로젝트 6월 계획은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효과측정 도구 개발
    &lt;ul&gt;
      &lt;li&gt;두번째 루프로 진입하여 가설을 검증하고, 개발이 가능한지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새로운 넛지 시나리오 기획
    &lt;ul&gt;
      &lt;li&gt;충전액이 늘어나도록 유도하는 넛지
        &lt;ul&gt;
          &lt;li&gt;넛징을 받는 유저가 스스로 운이 좋다고 느끼게 하기&lt;/li&gt;
          &lt;li&gt;넛징으로 캐시 관련 자극을 반복적으로 받도록 설계하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;충전하는 주기가 짧아지도록 유도하는 넛지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;디지털-사이니지&quot;&gt;디지털 사이니지&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;디지털사이니지 마일스톤 중 FGT 웹 솔루션 제작 단계에 곧 돌입합니다. 또한, 아이덴티피케이션 모델 개발에 착수 했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;넥슨-퍼스트-관련-헙업-문서-제안&quot;&gt;넥슨 퍼스트 관련 헙업 문서 제안&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/FGT%20%EC%98%81%EC%83%81%EB%B6%84%EC%84%9D%20%EA%B8%B0%EC%88%A0%20%ED%98%91%EC%97%85%20%EC%A0%9C%EC%95%88%EC%84%9C_v1.0.pdf&quot;&gt;&lt;u&gt;협업 제안서&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;넥슨 퍼스트 관련 향후 문제점이 될 만한 요소들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테스트 유저가 노출을 원하지 않거나, 모바일 테스트 시 카메라를 가리는 이슈
    &lt;ul&gt;
      &lt;li&gt;카메라 노출 시, 추가적인 혜택을 주는 방안을 고려&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 분석을 어떻게 활용할 수 있을 지에 대한 인사이트 부족
    &lt;ul&gt;
      &lt;li&gt;데이터 분석가의 리포트를 통해 인사이트를 줄 수 있는 방안을 고려&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;넥슨 퍼스트의 확정되지 않은 개발 기간
    &lt;ul&gt;
      &lt;li&gt;Dependency를 줄이는 방안으로 개발&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 넥슨 퍼스트와는 별도로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데모 분석 리포트&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데모 웹 콘솔&lt;/code&gt;을 제작해 추후 시연하는 방식으로 협의가 이루어 졌습니다.&lt;/p&gt;

&lt;p&gt;추가로 UX실에서 25G 용량의 게임 플레이 동영상을 제공해주었고, 이를 모델 개발과 리포트 개발에 활용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;facialexpression-모델-개발&quot;&gt;FacialExpression 모델 개발&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;영상을 통해 감정을 추론하는 모델은 목표로 했던 수준의 &lt;u&gt;개발이 완료&lt;/u&gt;되어, &lt;u&gt;추론 결과를 바탕으로 리포트&lt;/u&gt;를 개발 중입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NXLog랑 매핑하여 감정 변화 상태를 추적할 수 있는 리포트 샘플입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/reportsample.png&quot; alt=&quot;감정 리포트 타임라인 샘플&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;identification-모델-개발&quot;&gt;Identification 모델 개발&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;오프라인 광고 집행 시, &lt;u&gt;사람들이 해당 광고를 얼마나 관심있게 봤는 가&lt;/u&gt;를 측정하기 위함입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;object-detection&quot;&gt;Object Detection&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;u&gt;몇명의 사람들이 광고앞에 있는가&lt;/u&gt;를 알기 위해 Object Detection 모델을 먼저 연구했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 연구에 사용될 모델을 선정했던 기준은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tensorflow 기반 모델&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;👉 &lt;a href=&quot;https://github.com/tensorflow/models/tree/master/research/object_detection&quot;&gt;&lt;u&gt;Tensorflow2 Object Detection Model zoo&lt;/u&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;비교적 최근 모델&lt;/li&gt;
  &lt;li&gt;해상도가 높은 모델(1024x1024)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;테스트에 사용된 모델들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CenterNet HourGlass104 1024x1024 (CenterNet)&lt;/li&gt;
  &lt;li&gt;EfficientDet D4 1024x1024 (EfficientDet)&lt;/li&gt;
  &lt;li&gt;SSD MobileNet V2 FPNLite 640x640 (MobileNet)&lt;/li&gt;
  &lt;li&gt;SSD ResNet152 FPN 1024x1024 (RetinaNet)&lt;/li&gt;
  &lt;li&gt;Fast R-CNN ResNet152 V1 1024x1024 (Fast R-CNN)&lt;/li&gt;
  &lt;li&gt;Mask R-CNN Inception ResNet V2 1024x1024 (Mask R-CNN)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;test&quot;&gt;Test&lt;/h3&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/4k-002.mkv&quot;&gt;&lt;u&gt;테스트 영상 링크&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Face Detection으로 구현한 샘플입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/%EB%8D%B0%EB%AA%A81.gif&quot; alt=&quot;1차 데모&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Object Detection으로 구현한 샘플입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/%EB%8D%B0%EB%AA%A82.JPG&quot; alt=&quot;2차 데모&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/%EB%8D%B0%EB%AA%A83.JPG&quot; alt=&quot;2차 데모&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;evaluation-1&quot;&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;선정된 모델의 테스트 결과, 다음과 같은 성능을 보였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;MODEL&lt;/th&gt;
      &lt;th&gt;사&lt;/th&gt;
      &lt;th&gt;람&lt;/th&gt;
      &lt;th&gt;찾&lt;/th&gt;
      &lt;th&gt;은&lt;/th&gt;
      &lt;th&gt;수&lt;/th&gt;
      &lt;th&gt;속도&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Image1&lt;/td&gt;
      &lt;td&gt;Image2&lt;/td&gt;
      &lt;td&gt;Image3&lt;/td&gt;
      &lt;td&gt;Image 4&lt;/td&gt;
      &lt;td&gt;Image 5&lt;/td&gt;
      &lt;td&gt;동영상전체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CenterNet&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;130.68s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EfficientDet&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;608.38s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MobileNet&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;293.48s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RetinaNet&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;514.89s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;201.66s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;311.81s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 결과에 대한 분석은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존 논문에서 조사한대로 R-CNN의 성능이 우수한 것이 확인&lt;/li&gt;
  &lt;li&gt;의야한 결과는 원래 SSD 계열들이 속도가 빠르게 나와야하는데 정확도와 속도 측면에서 이상 결과를 보임
    &lt;ul&gt;
      &lt;li&gt;구현된 다른 모델들을 찾아보고 보충실험을 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속도가 가장 빠른 모델은 CenterNet&lt;/li&gt;
  &lt;li&gt;추가적으로 Yolo 계열와 SSD 모델을 새로 찾아서 추가 실험을 진행해야하겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;디지털-사이니지-6월-계획&quot;&gt;디지털 사이니지 6월 계획&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;디지털 사이니지 프로젝트 6월 계획은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FacialExpression 모델 기반 데모 리포트 완료 및 UX실 공유&lt;/li&gt;
  &lt;li&gt;감정 리포트 프론트엔드 콘솔 구현&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pytorch Identification 기반 모델&lt;/code&gt; 연구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;머신러닝-파이프라인&quot;&gt;머신러닝 파이프라인&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;머신러닝파트는 1년 간 머신러닝 서비스 운영 기술적 노하우를 축적하려 노력했습니다. 공유할 수 있는 결과물이 나오기 시작했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;첫-번째-자체-bi를-도입했습니다-쿠버네티스-기반의-jupyterhub를-구축했습니다&quot;&gt;첫 번째, 자체 BI를 도입했습니다. 쿠버네티스 기반의 JupyterHub를 구축했습니다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;현재, 랩스내 많은 분석 조직에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EC2 기반 EMR 제플린&lt;/code&gt;을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;마케팅 개발실내에서는 컨텐츠 서비스 개발팀, ADS 개발팀이 그러합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일 서버 프로세스&lt;/code&gt;를 사용하는 제플린은 많은 사용자가 동시 사용에 사용할 수 있으나,&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;일부 작업이 리소스가 많이 필요할 경우, 전체 리소스에 영향을 주어 다른 작업자의 작업을 방해하는 경우가 많습니다.&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;최악의 경우, 제플린 서버의 프로세스가 멈추어, EC2를 재시작하는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;때문에, 작업자마다 완전히 분리된 독립적인 분석 환경과 테스트 환경을 제공해줘야 합니다.&lt;/p&gt;

&lt;p&gt;머신러닝 파트는 쿠버네티스 기반의 JupyterHub를 구축하여 가능하게 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;http://mlhub.na.nexon.com/&quot;&gt;&lt;u&gt;머신러닝파트 주피터 허브&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;/2021/06/03/ApacheZeppelinVsJupyter-전지호.html&quot;&gt;&lt;u&gt;제플린과 주피터의 비교&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%EC%9E%A5%EB%B9%84%EC%9A%B4%EC%98%81%EC%82%AC%EB%A1%80.pdf&quot;&gt;&lt;u&gt;머신러닝 장비 운영 사례&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스 기반의 주피터허브는 사용자가 로그인 시, 그때마다 독립적인 도커 컨테이너를 만듭니다.&lt;/p&gt;

&lt;p&gt;독립된 컨테이너에서 실행되는 작업이 리소스가 부족해 폭파되더라도, 다른 컨테이너에 영향을 줄 수 없습니다.&lt;/p&gt;

&lt;p&gt;각 컨테이너마다 분석에 쓰이고자 하는 라이브러리 사양을 골라서 만들수 있고, 해당 컨테이너는 커스터 마이징이 가능합니다.&lt;/p&gt;

&lt;p&gt;머신러닝파트는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nxlog에 접근할 수 있는 Hadoop 기반의 pyspark 컨테이너&lt;/li&gt;
  &lt;li&gt;Pytorch 컨테이너&lt;/li&gt;
  &lt;li&gt;Tensorflow 컨테이너&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3개의 컨테이너를 내부 사양에 맞게 커스터마이징하여 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;10분 간, 사용하지 않는 컨테이너는 자동으로 내려갑니다. 따라서 쿠버네티스내 컴퓨팅 리소스는 효율적으로 관리됩니다.&lt;/p&gt;

&lt;p&gt;전 세계에서 가장 유명한 머신러닝와 데이터 분석도구인 kubeflow, sagemaker, 데이터브릭스에서 제공하는 기능입니다.&lt;/p&gt;

&lt;p&gt;기술 공유를 통해 각 조직마다 구축해 내부적으로 사용할 수 있을 것으로 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;두-번째-mlops-cicd를-도입했습니다&quot;&gt;두 번째, MLOps CI/CD를 도입했습니다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;아시다시피, 일반 웹서비스처럼 머신러닝 혹은 분석 서비스 또한 라이브 레벨에서는 많은 유지 보수의 비용이 들어갑니다.&lt;/p&gt;

&lt;p&gt;현재의 경우처럼 Job을 만들어 airflow로 실행하는 형태의 업무는 실제 대규모 서비스 레벨에 올라갈 경우, 많은 문제를 야기할 수 있습니다.&lt;/p&gt;

&lt;p&gt;일단, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;형상관리&lt;/code&gt;가 되지 않습니다.&lt;/p&gt;

&lt;p&gt;작업자가 실수를 범하여 서비스 단계에 잘못된 소스가 올라갈 경우,&lt;/p&gt;

&lt;p&gt;롤백에 취약하고 최악의 경우에 이전 코드를 찾을 수 없는 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;공동 작업의 경우, 코드를 수정한 사람이나, 배포를 한 사람을 찾아내기 힘들 수도 있습니다.&lt;/p&gt;

&lt;p&gt;서든어택 월핵탐지기 경우처럼 다른 조직과 협업하여 하루에 수십만 건 이미지를 머신러닝 코드로 처리하는 프로세스와 같은 서비스가 있다면,&lt;/p&gt;

&lt;p&gt;이러한 취약점은 감당하기 힘든 문제로 돌아올 수 도 있습니다.&lt;/p&gt;

&lt;p&gt;인텔리전스랩스의 분석 및 머신러닝 서비스가 네이버페이, 카카오페이같은 일반 사용자 대상 금융 서비스라고 가정하면 대부분의 분석 서비스가 큰 어려움을 겪을 것이라고 쉽게 생각할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에, 머신러닝 파이프라인에 MLOps라 불리는 CI/CD를 적용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/1_s3uqyy6y3Wo4G8BPiY7vwA.png&quot; alt=&quot;MLOps 배포 파이프라인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;월핵탐지&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FGT 감정추론&lt;/code&gt;의 경우,&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;개발자의 도움없이 작업자가 코드만 수정하여 배포, 롤백, 형상관리, 모니터링이 모두 가능합니다.&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://a4b2cf330e1d2464a951ba793aaae70e-596153973.ap-northeast-2.elb.amazonaws.com/&quot;&gt;&lt;u&gt;월핵탐지기 모니터링 ArgoCD&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://ad1f03f16a72740d68c582a87b928f1b-1924335043.ap-northeast-2.elb.amazonaws.com/&quot;&gt;&lt;u&gt;FGT 실시간 감정추론 모니터링 ArgoCD&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;오프라인광고-지역-선정&quot;&gt;오프라인광고 지역 선정&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;넥슨 유저의 위치정보 기반의 지역을 선정하다가 위치 기반 데이터의 한계를 느끼고 오프라인광고의 성과를 추적할 수 있는 새로운 아이데이션을 시도했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://confluence.nexon.com/pages/viewpage.action?pageId=389531331&quot;&gt;&lt;u&gt;오프라인광고 지역 선정&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/monthlyreport/%EC%98%A5%EC%99%B8%EA%B4%91%EA%B3%A0%EC%84%B1%EA%B3%BC%EC%B8%A1%EC%A0%95%EC%A0%9C%EC%95%88_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%ED%8C%8C%ED%8A%B8.pdf&quot;&gt;&lt;u&gt;[아이데이션]옥외광고소재와 성과측정&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;상시-업무&quot;&gt;상시 업무&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;넥슨과 인텔리전스랩스에 도움이 되는 업무를 지속적으로 하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;카트라이더 리그 지원&lt;/li&gt;
  &lt;li&gt;카트라이더 TMI 운영 및 리소스 업데이트&lt;/li&gt;
  &lt;li&gt;월핵탐지기 운영 및 요청사항 반영&lt;/li&gt;
  &lt;li&gt;사내 기술 블로그 운영&lt;/li&gt;
  &lt;li&gt;NDC 2021 발표 (권승진)&lt;/li&gt;
  &lt;li&gt;FGT 관련 논문 작업 중 (권승진)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>전지호</name></author><category term="monthlyreport" /><summary type="html">과금넛지와 디지털사이니지, 오프라인 광고지역 선정에 대한 리뷰입니다.</summary></entry><entry><title type="html">월말보고(5월)- 권승진</title><link href="http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EA%B6%8C%EC%8A%B9%EC%A7%84.html" rel="alternate" type="text/html" title="월말보고(5월)- 권승진" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EA%B6%8C%EC%8A%B9%EC%A7%84</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EA%B6%8C%EC%8A%B9%EC%A7%84.html">&lt;h1 id=&quot;디지털사이니지&quot;&gt;디지털사이니지&lt;/h1&gt;
&lt;h2 id=&quot;얼굴-분석-엔진---ux분석팀-넥슨-퍼스트-4월-제안서-송부--미팅&quot;&gt;얼굴 분석 엔진 - UX분석팀 넥슨 퍼스트 4월 제안서 송부 &amp;amp; 미팅&lt;/h2&gt;
&lt;p&gt;4월에 작성했던 제안서를 UX분석팀에 제안하였습니다. 다행히 긍정적으로 생각해주셨고 미팅을 진행 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;협업-포인트-긍정&quot;&gt;협업 포인트 긍정&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Usability Test 분석의 새로운 방향에 대한 기대&lt;br /&gt;
감정 분석과 NX LOG의 결합에 대한 기대&lt;br /&gt;
UX분석팀은 다양한 분석 방식 도입은 언제든 환영&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;협업-포인트-걱정&quot;&gt;협업 포인트 걱정&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;모바일 플레이시 카메라 가림&lt;br /&gt;
모바일 성능 한계로 인한 고사양 게임 + 고해상도 스트리밍 한계&lt;br /&gt;
상호 프로젝트 간 개발 기간 상이 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;제안된 방식이 테스트 참가자를 직접 촬영한 영상에 대한 분석인데, UX분석팀에서는 이 부분은 고려하지 않고 있었는데 이렇게 제안되어 신선했다는 반응이었습니다. 다만 넥슨 퍼스트에서도 테스트 참가자 얼굴 영상 녹화를 고려하고 있었고, 검토했지만 모바일 게임의 경우 게임을 플레이하면서 핸드폰을 잡는 그립 방식이 카메라를 가리는 경우가 많고, 고해상도 스트리밍이 한계가 있기 때문에 도입에 대해서는 좀 더 검토가 필요하다고 걱정하는 면이 있었습니다.&lt;/p&gt;

&lt;p&gt;그럼에도 불구하고, 차후에 코로나 상황이 끝난 뒤라도 실제 오프라인으로 참가자를 초대하는 방식의 FGT에서의 도입도 적극 희망한다는 의견을 주셨습니다.&lt;/p&gt;

&lt;h3 id=&quot;이후-협업&quot;&gt;이후 협업&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;UX분석팀 분들(김슬기님, 한가람님) 초대 후 시연&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;미팅 후 UX분석팀 분들(김슬기님, 한가람님)을 저희 파티션에 초대하여 프레임워크 동작 방식을 설명드리고 시연하는 자리를 가졌고, 저희 프레임워크 성능 시험을 위해 적극적으로 영상을 제공하겠다는 의사를 비춰주셨습니다. 후에 5/4에 UX분석팀 분들께서 게임을 플레이하면서 촬영한 영상을 전달 받았습니다.&lt;/p&gt;

&lt;h2 id=&quot;얼굴-분석-엔진---방향-설정&quot;&gt;얼굴 분석 엔진 - 방향 설정&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;방향 설정 - 플랫폼 의존 없이 다양한 영상 소스로부터 수집된 영상을 분석하는 파이프라인 구축&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 내용들을 바탕으로 저희 프로젝트는 결론적으로 플랫폼 의존 없이 영상을 입력으로 하는 분석 엔진을 만드는 것으로 의견을 모았고, 유튜브, FGT프레임워크, 넥슨퍼스트, 직접 입력등으로 수집되는 영상들을 분석하는 파이프라인을 제작하고 데모 레포트와 데모 웹 프로토타입을 제작해서 UX실에 전달하기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;얼굴-분석-엔진---진척-상황&quot;&gt;얼굴 분석 엔진 - 진척 상황&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;데모 섹션 리포트와 NX LOG 매핑 리포트 데모&lt;br /&gt;
모델 성능 개선&lt;br /&gt;
파이프라인 제작&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;게임 분석에 영감을 줄 수 있는 항목들을 선별하여, 데모 섹션 리포트를 제작하고 있고, 마무리 단계에 있습니다. 해당 내용을 UX분석 팀에 공유하여 피드백을 받을 예정이고, 항목이 정해지고 피드백을 거쳐 폴리싱 되면 해당 기획을 가지고 웹 프로토타입을 개발할 예정입니다.&lt;br /&gt;
-FGT결과글링크
&lt;br /&gt;&lt;br /&gt;
동시에 NX LOG에 매핑 되어 게임 LOG와 감정 표출의 상관관계에 대한 분석을 진행 중입니다.&lt;br /&gt;
-도영님그림링크
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;초기 프로토타입 데모에 있었던 몇가지 버그를 수정하고, 몇몇 참가자에 대해 Fear 감정이 많이 발생하는 부분을 모델 개선을 통해 수정했습니다.&lt;br /&gt;
파이프라인 제작에 관한 기술적인 이야기는 다음 포스트에서 확인할 수 있습니다.
&lt;br /&gt;
-링크&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다음-마일스톤&quot;&gt;다음 마일스톤&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다음 계획은 리포트를 보내고 피드백을 받은 후, 리포트를 볼 수 있는 웹 프로토타입을 제작할 것이다.&lt;/li&gt;
  &lt;li&gt;모델 개발 완료 후, 프로토타입 개발시간을 이용해 아이덴티피케이션 모델을 개발할 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-이후 혁근님 글 이어서&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기타-사항&quot;&gt;기타 사항&lt;/h2&gt;
&lt;p&gt;상용 서비스 중인 주요 얼굴 분석 엔진들의 기능과 비용에 대해 조사했고, Face Play 프로젝트에 공유하였습니다.&lt;br /&gt;
https://confluence.nexon.com/pages/viewpage.action?pageId=382323477&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;추가 특허 확보에 대해 조사했고, 사내 IP팀 오승현님과 논의하였고, 이후 리앤목 특허법인의 신경하 변리사님과 미팅 진행하였습니다. 
주요 내용은&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;얼굴 분석 장치 자체로서는 특허 의미를 갖기가 어렵다. Face Play만의 구체적인 게임 방식에 얼굴 분석 장치를 활용하는 것에 특허 의미를 부여할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;였습니다.&lt;br /&gt;
https://confluence.nexon.com/pages/viewpage.action?pageId=382333496&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;NDC에서 해당 내용으로 발표를 신청해서 발표하게 되었고, 5/10 촬영 했습니다. 6/9 송출 예정이라고 합니다. 회사 내부 이야기는 최대한 배제하고, 흥미 위주와 공개 기술 위주로 발표하였습니다.&lt;br /&gt;
https://ndc.nexon.com/common/CommonNotPeriod?category=sessionday1&lt;/p&gt;</content><author><name>권승진</name></author><category term="computervision" /><category term="objectdetection" /><category term="fgt" /><summary type="html">5월 보고용 자료입니다.</summary></entry><entry><title type="html">FGT 파이프라인 1 - 유튜브 다운로드</title><link href="http://0.0.0.0:4000/2021/06/03/FGT-p1-%EC%9C%A0%ED%8A%9C%EB%B8%8C%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.html" rel="alternate" type="text/html" title="FGT 파이프라인 1 - 유튜브 다운로드" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/FGT-p1-%EC%9C%A0%ED%8A%9C%EB%B8%8C%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/FGT-p1-%EC%9C%A0%ED%8A%9C%EB%B8%8C%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.html">&lt;h1 id=&quot;fgt-영상-분석-파이프라인&quot;&gt;FGT 영상 분석 파이프라인🤲&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;영상 확보부터 리포트까지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;영상 분석 분야에서는 영상 데이터가 용량이 크기 때문에 데이터를 확보하고, 전처리하고, 분석하는 단계를 잘 세분화해서 일을 두번하지 않게 만들어야 합니다.&lt;br /&gt;
이 영상 처리 파이프라인 처리 과정을 소개해보려고 합니다.&lt;br /&gt;
&lt;img src=&quot;https://solution-userstats.s3.amazonaws.com/techblogs/seungjin/2021-06-04/1.png&quot; alt=&quot;Process&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 과정은 원터치 실행도 가능해야하고, 따로 실행도 가능해야합니다.
그리고 잦은 코드 변경 없이 파이프라인으로 굳히기 위해 모든 과정을 다 Docker로 실행되도록 만들었고, 추가된다면 그 역시 Docker로 만들어질 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그 중 제일 먼저 유튜브 영상을 다운로드 자동화 하는 일부터 설명해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;1-유튜브-다운로드&quot;&gt;1. 유튜브 다운로드&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;유튜브 영상을 URL만 주면 가장 높은 해상도 영상을 다운 받아 저장&lt;br /&gt;
pytube라는 라이브러리 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬으로 유튜브에서 영상을 다운 받는 일은 당연히 인터넷에 찾아보면 많이 있는 일이지만, 몇가지 고려할 점이 있습니다. 유튜브 자체에서 영상을 다운로드 할 때, 720p이하 영상은 일시 전송하고, 720p가 넘는 고화질 영상은 다 스트리밍 형식의 전송이며, 이 때는 비디오와 오디오가 분리되서 전송되게 되어있다고 합니다.&lt;br /&gt;
그래서 라이브러리를 이용해서 그냥 4k영상을 다운 받으면 영상만 다운로드 되기 때문에, 오디오와 비디오 데이터를 다운 받아서 합쳐주는 작업을 거쳐야합니다. 코드로 보면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytube&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;YouTube&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 유튜브영상을 다운로드하기 위한 모듈
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os.path&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 경로를 설정하기 위한 모듈
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ffmpeg&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 미디어를 변환하기 위한 모듈
&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# link 인자는 gui에서 입력된 값을 받을 때 사용
&lt;/span&gt;        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;./&quot;&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;YouTube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getVideoName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'''(GUI버전) 비디오 이름을 내보내는 함수'''&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;downloadMp3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'''mp3 파일로 다운로드하는 함수'''&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# mp4형태지만 영상 없이 소리만 있는 파일 다운로드
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;streams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only_audio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_filename&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# mp4로 다운받은 영상제목(파일명과 같음)
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'mp3'&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# mp3로 변환된 파일명
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# mp4에서 mp3로 변환
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;ffmpeg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;overwrite_output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 변환되기 전 mp4파일 삭제
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 저장한 파일명 리턴
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;downloadMp4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'''mp4 파일로 다운로드하는 함수'''&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;audio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloadMp3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# mp3파일 다운로드
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;streams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_extension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mp4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'resolution'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# mp4파일 다운로드
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# mp4로 해상도 높은 파일을 받으면 vcodec만 존재
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# -&amp;gt;비디오에 소리를 입히려면 acodec 있는 파일 받아 FFmpeg로 병합
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# -&amp;gt;downloadMp3로 mp3파일을 받고 오디오 소스로 사용
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;input_audio_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input_video_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;inputAudio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffmpeg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_audio_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inputVideo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffmpeg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_video_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 영상에 소리 입혀 &quot;new.mp4&quot;파일로 내보내기
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;ffmpeg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputAudio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputVideo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;new.mp4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vcodec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'copy'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;overwrite_output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 변환이 끝나 더 이상 필요 없는 mp3, mp4 파일 지우기
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# &quot;new.mp4&quot;를 영상 제목으로 바꾸기
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;new.mp4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_filename&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 저장한 파일명 리턴
&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'https://www.youtube.com/watch?v=r7ZZCKmX2OI'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getVideoName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;downloaded_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloadMp4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloaded_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://kiffblog.tistory.com/162&quot;&gt;코드 원본 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그대로 실행하면, “[BE ORIGINAL] ITZY(있지) 마피아 In the morning (4K)” 유튜브를 최대 해상도로 mp4파일로 가져오게 됩니다.&lt;br /&gt;
만약에 다른 조건으로 영상을 다운 받고 싶다면 유튜브에서 받을 수 있는 데이터 형태를 yt.streams.filter를 이용해서 선택해야 합니다. 예를 들어 “[BE ORIGINAL] ITZY(있지) 마피아 In the morning (4K)” 유튜브에서 가능한 모든 옵션을 쭉 불러오면 다음과 같습니다.&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;옵션 펼쳐보기&lt;/summary&gt;
&lt;div&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&amp;lt;Stream: itag=&quot;160&quot; mime_type=&quot;video/mp4&quot; res=&quot;144p&quot; fps=&quot;30fps&quot; vcodec=&quot;avc1.4d400c&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;278&quot; mime_type=&quot;video/webm&quot; res=&quot;144p&quot; fps=&quot;30fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;394&quot; mime_type=&quot;video/mp4&quot; res=&quot;144p&quot; fps=&quot;30fps&quot; vcodec=&quot;av01.0.00M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;133&quot; mime_type=&quot;video/mp4&quot; res=&quot;240p&quot; fps=&quot;30fps&quot; vcodec=&quot;avc1.4d4015&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;242&quot; mime_type=&quot;video/webm&quot; res=&quot;240p&quot; fps=&quot;30fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;395&quot; mime_type=&quot;video/mp4&quot; res=&quot;240p&quot; fps=&quot;30fps&quot; vcodec=&quot;av01.0.00M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;18&quot; mime_type=&quot;video/mp4&quot; res=&quot;360p&quot; fps=&quot;30fps&quot; vcodec=&quot;avc1.42001E&quot; acodec=&quot;mp4a.40.2&quot; progressive=&quot;True&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;134&quot; mime_type=&quot;video/mp4&quot; res=&quot;360p&quot; fps=&quot;30fps&quot; vcodec=&quot;avc1.4d401e&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;, 
 &amp;lt;Stream: itag=&quot;243&quot; mime_type=&quot;video/webm&quot; res=&quot;360p&quot; fps=&quot;30fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;396&quot; mime_type=&quot;video/mp4&quot; res=&quot;360p&quot; fps=&quot;30fps&quot; vcodec=&quot;av01.0.01M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;135&quot; mime_type=&quot;video/mp4&quot; res=&quot;480p&quot; fps=&quot;30fps&quot; vcodec=&quot;avc1.4d401f&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;, 
 &amp;lt;Stream: itag=&quot;244&quot; mime_type=&quot;video/webm&quot; res=&quot;480p&quot; fps=&quot;30fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;397&quot; mime_type=&quot;video/mp4&quot; res=&quot;480p&quot; fps=&quot;30fps&quot; vcodec=&quot;av01.0.04M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;136&quot; mime_type=&quot;video/mp4&quot; res=&quot;720p&quot; fps=&quot;30fps&quot; vcodec=&quot;avc1.4d401f&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;247&quot; mime_type=&quot;video/webm&quot; res=&quot;720p&quot; fps=&quot;30fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;298&quot; mime_type=&quot;video/mp4&quot; res=&quot;720p&quot; fps=&quot;60fps&quot; vcodec=&quot;avc1.4d4020&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;302&quot; mime_type=&quot;video/webm&quot; res=&quot;720p&quot; fps=&quot;60fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;398&quot; mime_type=&quot;video/mp4&quot; res=&quot;720p&quot; fps=&quot;60fps&quot; vcodec=&quot;av01.0.08M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;299&quot; mime_type=&quot;video/mp4&quot; res=&quot;1080p&quot; fps=&quot;60fps&quot; vcodec=&quot;avc1.64002a&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;303&quot; mime_type=&quot;video/webm&quot; res=&quot;1080p&quot; fps=&quot;60fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;399&quot; mime_type=&quot;video/mp4&quot; res=&quot;1080p&quot; fps=&quot;60fps&quot; vcodec=&quot;av01.0.09M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;308&quot; mime_type=&quot;video/webm&quot; res=&quot;1440p&quot; fps=&quot;60fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;400&quot; mime_type=&quot;video/mp4&quot; res=&quot;1440p&quot; fps=&quot;60fps&quot; vcodec=&quot;av01.0.12M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;315&quot; mime_type=&quot;video/webm&quot; res=&quot;2160p&quot; fps=&quot;60fps&quot; vcodec=&quot;vp9&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;,
 &amp;lt;Stream: itag=&quot;401&quot; mime_type=&quot;video/mp4&quot; res=&quot;2160p&quot; fps=&quot;60fps&quot; vcodec=&quot;av01.0.13M.08&quot; progressive=&quot;False&quot; type=&quot;video&quot;&amp;gt;]  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/div&gt;
&lt;/details&gt;
&lt;p&gt;&lt;br /&gt;
간단히 요약하면 다운로드 옵션을&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;only video or only audio&lt;/li&gt;
  &lt;li&gt;mp4 or webm&lt;/li&gt;
  &lt;li&gt;해상도 144p ~ 2160p&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정도 가지고 있다고 볼 수 있을 것 같습니다.&lt;/p&gt;

&lt;p&gt;사용하는 입장에서는 yt.streams.filter함수를 이용해서 원하는 데이터와 원하는 해상도, 원하는 확장자 포맷을 설정한 다음에 다운 받으면 된다는 것만 알고 있으면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;video&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;streams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_extension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mp4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'resolution'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 mp4의 확장자 중에 해상도 순서로 정렬해서 가장 마지막 것을 선택하도록 하는 필터가 됩니다. mp4중 최대 해상도 영상을 선택하게 되겠죠.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-docker-&quot;&gt;2. Docker 💬&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;코덱 때문에 특히 특히 무~~조건 Docker를 쓰는게 정신 건강에 좋음.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 pytube라는 코드는 내부적으로 ffmpeg-python 라이브러리를 쓰고 있고, 이 ffmpeg-python 라이브러리는 또, ffmpeg라는 도구를 실행해서 결과를 얻게 되어 있고, 이 ffmpeg는 여러 코덱을 사용해서 수행하게 되는데, 결국 코덱 설치가 필요한 일이라 같은 파이썬 코드와 환경이라도 이 컴퓨터에서 되던 코드가 저 컴퓨터가면 코덱이 없어서 안되고 그런 일들이 일어납니다. 특히, Windows OS에서 많이 일어납니다.&lt;br /&gt;
그래서 운영체제 단부터 코덱 설치까지 모두 환경 조성이 가능한 docker가 여기서 더 빛을 발하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN apt-get install -y ffmpeg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 설치해주면, 리눅스 환경에서 어려움 없이 pytube 라이브러리를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-업로드&quot;&gt;3. 업로드&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;S3에 영상을 적재&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;S3에 영상을 적재하면 됩니다. 이건 모두가 아시다시피 boto3을 활용하면 됩니다. 실제 쓰이는 코드에서 발췌했는데 대략적으로 이렇게 하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boto3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'s3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;region_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_RESION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aws_access_key_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_AWS_ACCESS_KEY_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aws_secret_access_key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_AWS_SECRET_ACCESS_KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upload_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;local_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음엔 이 코드들이 어떻게 분석 엔진에 들어가게 되는지 써보겠습니다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;안녕👋&lt;/p&gt;</content><author><name>권승진</name></author><category term="fgt" /><summary type="html">FGT 파이프라인 첫번째 유튜브 영상 다운로드 코드</summary></entry><entry><title type="html">Apache Zeppelin과 Jupyter의 비교</title><link href="http://0.0.0.0:4000/2021/06/03/ApacheZeppelinVsJupyter-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="Apache Zeppelin과 Jupyter의 비교" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/ApacheZeppelinVsJupyter-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/ApacheZeppelinVsJupyter-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;아피치-제플린과-주피터의-간단-비교&quot;&gt;아피치 제플린과 주피터의 간단 비교&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 분석의 워크플로를 개선하는 아파치 제플린과 주피터를 간단하게 비교해볼께요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-설치-&quot;&gt;1. 설치 🛠&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;설치 단계에서부터 막히면, 아주 짜증이 많이납니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주피터의 설치는 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;그냥 명령어를 통해 로컬에 설치만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;로컬 환경을 쉽게 서버에 올리기 위해, 버전 별로 빌드된 도커 버전도 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%A3%BC%ED%94%BC%ED%84%B0%20%EC%84%A0%ED%83%9D.JPG&quot; alt=&quot;다양한 주피터 도커&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html&quot;&gt;주피터&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://github.com/jupyter/docker-stacks&quot;&gt;주피터 도커 깃허브&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그에 비해, 제플린의 설치는 조금 더 복잡합니다. 압축을 풀고 서버에서 실행해야 하죠.&lt;/p&gt;

&lt;p&gt;많은 기능을 함께 사용할려면 소스를 빌드하고 다시 실행해하는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;첫 번째 대결은, Jupyter의 손을 들어줍니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-커뮤니티-&quot;&gt;2. 커뮤니티 💬&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;큰 커뮤니티는 레퍼런스와 도움을 받기 위해 아주 중요한 요소입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jupyter의 커뮤니티는 이 Zeppelin보다 상당히 크고 훨씬 더 많은 외부 시스템을 지원합니다.&lt;/p&gt;

&lt;p&gt;그러나 Zeppelin의 커뮤니티는 성장 중이나 아직은 Jupyter에 밀리는 모습을 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;두 번째 대결은, Jupyter의 손을 들어줍니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/compatition.jpg&quot; alt=&quot;구글 트렌드 비교&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-다중-사용자-지원-&quot;&gt;3. 다중 사용자 지원 👨‍👩‍👦‍👦&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;공용 환경에서 다중 사용자 지원은 필수입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zeppelin는 다중 사용자를 지원하며,  Jupyter는 다중 사용자를 지원하지 않습니다.&lt;/p&gt;

&lt;p&gt;세 번째 대결은, Zeppelin의 승리일까요?&lt;/p&gt;

&lt;p&gt;JupyterHub라는 Jupyter 확장 리소스는 다중 사용자 지원을 약속합니다.&lt;/p&gt;

&lt;p&gt;하지만 Zeppelin에 비해 Jupyter는 사용자마다 별도의 서버가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;이어질 내용으로 인해 이번 대결은 보류하겠습니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-다중-사용자-지원-시-리소스-분배-&quot;&gt;4. 다중 사용자 지원 시 리소스 분배 👨‍👩‍👦‍👦&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중 사용자가 많은 리소스를 동시에 사용할 때, 이에 대한 대응은 어떨까요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zeppelin은 서버 단일 프로세스를 사용합니다. 다중 사용자의 이용에 취약하죠.&lt;/p&gt;

&lt;p&gt;이를 회피하기 위해, conda 환경과 docker를 Zeppelin 내부에서 지원합니다.&lt;/p&gt;

&lt;p&gt;Jupyter는 어떨까요?&lt;/p&gt;

&lt;p&gt;Jupyter는 애초에 다중 사용자를 지원하지않으니, JupyterHub를 살펴봅시다.&lt;/p&gt;

&lt;p&gt;JupyterHub는 각 사용자마다 서버를 따로 제공해야하니 단일 서버 프로세스를 사용한다 하더라도, 서로 영향을 주지 않습니다.&lt;/p&gt;

&lt;p&gt;하지만 각각의 서버를 구축하는 비용에 대한 문제는 어떻게 할까요?&lt;/p&gt;

&lt;p&gt;JupyterHub는 쿠버네티스 환경을 제공하는 버전을 따로 내놨습니다.&lt;/p&gt;

&lt;p&gt;하나의 서버에서 동작하는 쿠버네티스 환경에서의 JupyterHub는 각각의 사용자에 대해 가상의 컨테이너를 제공하여, 분리된 작업환경을 제공하는 동시에 서버 구축 비용을 줄일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;네 번째 대결은, 주피터의 손을 들어줍니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-확장프로그램-&quot;&gt;5. 확장프로그램 📥&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 많은 기능을 사용하고 싶다면…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jupyter는 약 20 개만있는 Zeppelin의 인터프리터 유형에 대해 지원되는 엔진이 85 개가 넘는 큰 목록으로 인해 승리합니다. 다양한 언어를 사용하고 싶다면, 주피터를 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-차트---&quot;&gt;6. 차트 📊 📈 📉&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 시각화를 이용하여, 비주얼라이징 툴을 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jupyter와 Zeppelin을 둘 다 다양한 비주얼라이징 툴을 플로팅하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;따라서, 대결은 무승부입니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-결론&quot;&gt;7. 결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;개인의 선호도에 따라, 선택은 자유.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하지만, 많은 부분에서 Jupyter의 우세를 점칠 수 있습니다. 최근 가장 핫한 개발트렌드인 docker와 쿠버네티스 지원이 우수한 것은 차이를 더 크게 만드는 요소일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;위와 같은 이유로,&lt;/p&gt;

&lt;p&gt;우리 팀은 &lt;b&gt;&lt;u&gt;쿠버네티스 환경에 JupyterHub&lt;/u&gt;&lt;/b&gt;를 구축하여 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;도움이 되셨길 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/netflixjupyter.png&quot; alt=&quot;넷플릭스도 쓰는 주피터&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;안녕👋&lt;/p&gt;</content><author><name>전지호</name></author><category term="zeppelin" /><category term="jupyter" /><summary type="html">데이터 분석의 워크플로를 개선하는 아파치 제플린과 주피터를 간단하게 비교해볼께요.</summary></entry><entry><title type="html">월말보고(5월)- 최혁근</title><link href="http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EC%B5%9C%ED%98%81%EA%B7%BC.html" rel="alternate" type="text/html" title="월말보고(5월)- 최혁근" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EC%B5%9C%ED%98%81%EA%B7%BC</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/%EC%9B%94%EB%A7%90%EB%B3%B4%EA%B3%A0-5%EC%9B%94-%EC%B5%9C%ED%98%81%EA%B7%BC.html">&lt;h1 id=&quot;face-identification-시스템&quot;&gt;Face Identification 시스템&lt;/h1&gt;

&lt;h2 id=&quot;face-identification-시스템-1&quot;&gt;Face Identification 시스템&lt;/h2&gt;
&lt;h3 id=&quot;개요&quot;&gt;개요&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;필요성
    &lt;ul&gt;
      &lt;li&gt;오프라인 광고측정의 첫걸음&lt;/li&gt;
      &lt;li&gt;사람들은
        &lt;ul&gt;
          &lt;li&gt;광고를 얼마나 보는가?&lt;/li&gt;
          &lt;li&gt;얼마나 집중하는가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이런 것을 어떻게 측정할 것인가?
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;카메라 + 얼굴인식으로 이걸 파악해보자&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;방법
    &lt;ul&gt;
      &lt;li&gt;카메라가 설치된 디지털 전광판에 광고를 송출
        &lt;ul&gt;
          &lt;li&gt;광고는 태그와 메타데이터로 어떤 종류의 광고인지 추적 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;광고 송출중에 카메라 앞으로 다니는 사람들을 파악
        &lt;ul&gt;
          &lt;li&gt;화면에 잡힌 사람들을 개별적으로 인식&lt;/li&gt;
          &lt;li&gt;DB에서 사람들을 누구인지 특징 / 추가 / 추적&lt;/li&gt;
          &lt;li&gt;사람들이 광고에 시청여부 판단&lt;/li&gt;
          &lt;li&gt;사람들의 집중시간 판단&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;광고별 시청률 / 집중률 등등 통계자료를 report&lt;/li&gt;
      &lt;li&gt;관리자 모드에는 실시간 관찰 UI&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세부기능 &amp;amp; 기술스택
    &lt;ul&gt;
      &lt;li&gt;사람 인식
        &lt;ul&gt;
          &lt;li&gt;Object Detection&lt;/li&gt;
          &lt;li&gt;Human Detecetion&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;얼굴 인식
        &lt;ul&gt;
          &lt;li&gt;Face Detection&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사람 분류
        &lt;ul&gt;
          &lt;li&gt;Face embedding&lt;/li&gt;
          &lt;li&gt;Face Verification / Identification&lt;/li&gt;
          &lt;li&gt;Similarity&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;광고시청 / 집중
        &lt;ul&gt;
          &lt;li&gt;Head Pose Estimation&lt;/li&gt;
          &lt;li&gt;Eye tracking&lt;/li&gt;
          &lt;li&gt;Engagement detection&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사람 정보 저장
        &lt;ul&gt;
          &lt;li&gt;ID&lt;/li&gt;
          &lt;li&gt;방문횟수&lt;/li&gt;
          &lt;li&gt;머문 시간&lt;/li&gt;
          &lt;li&gt;시청한 시간&lt;/li&gt;
          &lt;li&gt;사진정보&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요구사항
    &lt;ul&gt;
      &lt;li&gt;성능&lt;/li&gt;
      &lt;li&gt;속도&lt;/li&gt;
      &lt;li&gt;장비&lt;/li&gt;
      &lt;li&gt;환경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일정
    &lt;ul&gt;
      &lt;li&gt;개발&lt;/li&gt;
      &lt;li&gt;서베이
        &lt;ul&gt;
          &lt;li&gt;기술&lt;/li&gt;
          &lt;li&gt;논문&lt;/li&gt;
          &lt;li&gt;기타&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;문제점 분석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;시스템-세부사항&quot;&gt;시스템 세부사항&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;카메라 대기 (동영상으로도 테스트 가능)
    &lt;ul&gt;
      &lt;li&gt;Cam에서 영상을 프레임 단위로 분리 / 이미지화&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;화질 / 영상 사이즈 고려&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;화면에서 사람 / 얼굴 인식
    &lt;ul&gt;
      &lt;li&gt;Object Detection&lt;/li&gt;
      &lt;li&gt;Face Detection&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사람 ID 확인
    &lt;ul&gt;
      &lt;li&gt;얼굴 사진을 embedding해서 vector로 변환&lt;/li&gt;
      &lt;li&gt;기존 DB에 similarity 계산, 유사도가 높은 순 정리&lt;/li&gt;
      &lt;li&gt;Top1, Top5 등등을 통해서 사람 선별 기준 확립&lt;/li&gt;
      &lt;li&gt;얼굴이 아닌 사람 전체 모습을 통해서 이전 프레임과의 연관성을 통해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tracking
    &lt;ul&gt;
      &lt;li&gt;확인한 사람을 frame단위로 계속 마킹해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;추가적으로-리서치가-필요한-분야&quot;&gt;추가적으로 리서치가 필요한 분야&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Human Pose Estimation
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/MVIG-SJTU/AlphaPose&quot;&gt;AlphaPose&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/facebookresearch/DetectAndTrack&quot;&gt;Detect And Track&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Object Tracking&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;research1--object-detection&quot;&gt;Research1 : Object Detection&lt;/h2&gt;
&lt;h3 id=&quot;개요-1&quot;&gt;개요&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사람을 인식하기 위해서는 기존의 물체 인식 (Object Detection) 모델들을 사용한다.&lt;/li&gt;
  &lt;li&gt;실시간으로 진행하기 위해서는 추론 속도가, 후처리를 하기 위해서는 정확도가 중요하다.&lt;/li&gt;
  &lt;li&gt;연구된 여러 가지 구현체들을 실험용 데모영상을 이용해서 정확도와 속도를 측정하고&lt;/li&gt;
  &lt;li&gt;우리 시스템에 어울리는 모델이 무엇일지를 선별한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실험설계&quot;&gt;실험설계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 데이터
    &lt;ul&gt;
      &lt;li&gt;동영상 파일&lt;/li&gt;
      &lt;li&gt;가장 일반적인 거리영상인 지하철입구 영상&lt;/li&gt;
      &lt;li&gt;많은 사람들이 지나다닐 때 사람들을 정확히 포착할 수 있는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 동영상 &lt;a href=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/4k-002.mkv&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-1-tensorflow-object-detection-zoo&quot;&gt;1-1. Tensorflow Object Detection Zoo&lt;/h2&gt;
&lt;h3 id=&quot;1-테스트-개요&quot;&gt;1. 테스트 개요&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 모델
    &lt;ul&gt;
      &lt;li&gt;Object Detection 6가지 모델
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://github.com/tensorflow/models/tree/master/research/object_detection&quot;&gt;Tensorflow2 Object Detection Model zoo&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;기존에 한번식 break-through를 만들어냈던 모델들&lt;/li&gt;
          &lt;li&gt;최근 소개된 모델들도 추가해서&lt;/li&gt;
          &lt;li&gt;해상도가 높은 모델들 선정 (1024x1024)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;선정된 모델들
        &lt;ul&gt;
          &lt;li&gt;CenterNet HourGlass104 1024x1024 (CenterNet)&lt;/li&gt;
          &lt;li&gt;EfficientDet D4 1024x1024 (EfficientDet)&lt;/li&gt;
          &lt;li&gt;SSD MobileNet V2 FPNLite 640x640 (MobileNet)&lt;/li&gt;
          &lt;li&gt;SSD ResNet152 FPN 1024x1024 (RetinaNet)&lt;/li&gt;
          &lt;li&gt;Fast R-CNN ResNet152 V1 1024x1024 (Fast R-CNN)&lt;/li&gt;
          &lt;li&gt;Mask R-CNN Inception ResNet V2 1024x1024 (Mask R-CNN)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 방법
    &lt;ol&gt;
      &lt;li&gt;정확도 테스트
        &lt;ul&gt;
          &lt;li&gt;임의로 선별한 몇 개의 이미지에 대해서&lt;/li&gt;
          &lt;li&gt;개별 모델을 실행해서 물체를 인식하고&lt;/li&gt;
          &lt;li&gt;그 중에서 사람으로 판단하는 확률이 50% 이상인 결과들에 대해서&lt;/li&gt;
          &lt;li&gt;Box 표시하고 이미지로 출력&lt;/li&gt;
          &lt;li&gt;몇 명이나 사람을 찾아냈는지, 잘못 인식한 것은 얼마나 되는지 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;추론 속도 테스트
        &lt;ul&gt;
          &lt;li&gt;동영상 전체를(10초, 600 frams)&lt;/li&gt;
          &lt;li&gt;프레임별로 읽으면서&lt;/li&gt;
          &lt;li&gt;모델 추론을 진행하고 결과를 확인해보는 방식&lt;/li&gt;
          &lt;li&gt;추론 시 batchsize를 1, 5로 변화시켜가면서 시간 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 테스트를 해보고 우리 환경에 맞는 모델을 선정하는 것이 목표&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-사람인식-테스트&quot;&gt;2. 사람인식 테스트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;MODEL&lt;/th&gt;
      &lt;th&gt;사&lt;/th&gt;
      &lt;th&gt;람&lt;/th&gt;
      &lt;th&gt;찾&lt;/th&gt;
      &lt;th&gt;은&lt;/th&gt;
      &lt;th&gt;수&lt;/th&gt;
      &lt;th&gt;속도&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Image1&lt;/td&gt;
      &lt;td&gt;Image2&lt;/td&gt;
      &lt;td&gt;Image3&lt;/td&gt;
      &lt;td&gt;Image 4&lt;/td&gt;
      &lt;td&gt;Image 5&lt;/td&gt;
      &lt;td&gt;동영상전체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CenterNet&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;130.68s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EfficientDet&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;608.38s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MobileNet&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;293.48s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RetinaNet&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;514.89s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;201.66s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mast R-CNN&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;311.81s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;테스트결과 (TODO : 링크주소 수정)
    &lt;ul&gt;
      &lt;li&gt;Image1
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result1.png&quot; alt=&quot;테스트결과1&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image2
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result2.png&quot; alt=&quot;테스트결과2&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image3
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result3.png&quot; alt=&quot;테스트결과3&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image4
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result4.png&quot; alt=&quot;테스트결과4&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Image5
  &lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/hgchoi16/test_result5.png&quot; alt=&quot;테스트결과5&quot; id=&quot;popup&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-결과분석-및-여담&quot;&gt;3. 결과분석 및 여담&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기존 논문에서 조사한대로 R-CNN의 성능이 우수한 것이 확인됌&lt;/li&gt;
  &lt;li&gt;의야한 결과는 원래 SSD 계열들이 속도가 빠르게 나와야하는데 정확도와 속도 측면에서 결과가 이상해보인다.
    &lt;ul&gt;
      &lt;li&gt;구현된 다른 모델들을 찾아보고 보충실험을 진행해봐야하겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CenterNet의 경우도 좋은 성능을 보여주고 있다. 이번 실험에서는 속도도 가장 빨랐다.&lt;/li&gt;
  &lt;li&gt;추가적으로 Yolo계열와 SSD 모델을 새로 찾아서 추가실험을 진행해야하겠다.&lt;/li&gt;
  &lt;li&gt;이 모델에 추가해서 얼굴인식 모델들도 결합해서 함께 진행해보자!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-앞으로-진행해야할-내용&quot;&gt;4. 앞으로 진행해야할 내용&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Pytorch 모델들 조사
    &lt;ul&gt;
      &lt;li&gt;간단하게 테스트해본 결과&lt;/li&gt;
      &lt;li&gt;이쪽 모델들이 사용하거나 변형하기가 훨씬 쉬어보인다.&lt;/li&gt;
      &lt;li&gt;제일 기본적인 예제 - &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html#torchvision-object-detection-finetuning-tutorial&quot;&gt;TORCHVISION OBJECT DETECTION FINETUNING TUTORIAL&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;이런 식으로 사람만을 대상으로하는 detection 모델 개발 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 기법들 조사 및 적용&lt;/li&gt;
  &lt;li&gt;자체 학습하면 어떻게 데이터를 구하고 어떻게 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-2-pytorch-test&quot;&gt;1-2. Pytorch Test&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 진행중&lt;/li&gt;
  &lt;li&gt;torchvision에서 기본으로 제공되는 모델이
    &lt;ul&gt;
      &lt;li&gt;Mask R-CNN ResNet50 FPN&lt;/li&gt;
      &lt;li&gt;Tensorflow의 Mask R-CNN에서 backbone architecture로 사용된 Inception ResNet V2 1024x1024보다 가벼운 모델&lt;/li&gt;
      &lt;li&gt;이 모델 최상단에 추가로 Layer를 하나 더 두고 Person Class만을 따로 디텍션하도록 fine tuning 하는 tutorial이 존재&lt;/li&gt;
      &lt;li&gt;이 과정만으로도 훨씬 무거운 tensorflow모델보다 빠르고 비슷한 성능을 보이는 것으로 확인됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델 다루기나 코딩도 pytorch 쪽이 훨씬 편리하기 때문에 이걸 중심으로 개발 진행
    &lt;ul&gt;
      &lt;li&gt;대신 성능 관련해서는 확실하게 문서화 진행 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>최혁근</name></author><category term="computervision" /><category term="objectdetection" /><summary type="html">5월 보고용 자료입니다.</summary></entry><entry><title type="html">AWS S3 데이터 Lifecycle 기능을 이용하여 정리하기</title><link href="http://0.0.0.0:4000/2021/06/03/S3Lifecycle-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS S3 데이터 Lifecycle 기능을 이용하여 정리하기" /><published>2021-06-03T10:00:00-05:00</published><updated>2021-06-03T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/03/S3Lifecycle-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/03/S3Lifecycle-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;너는-어쩜-정리도-안하고-방을-돼지우리-같이-하고-사니&quot;&gt;“너는 어쩜 정리도 안하고 방을 돼지우리 같이 하고 사니…”&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리, S3라도 정리합시다. 꿀꿀 🐷&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Amazon S3를 이용하여 로그 및 분석 결과 혹은 파일을 저장하여 사용하다 보면 어느새 너무 많은 양의 데이터가 축적됩니다.&lt;/p&gt;

&lt;p&gt;데이터가 많아지면 많아질 수록, 스토리지 요금도 엄청나게 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%97%84%EC%B2%AD%EB%82%9C%EC%9A%A9%EB%9F%89.JPG&quot; alt=&quot;엄청난 용량&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 중 사용하는 데이터나 파일은 상관이 없으나, 사용하지 않는 데이터가 너무 많이 쌓이면 문제가 발생할 수 도 있습니다.&lt;/p&gt;

&lt;p&gt;AWS Concsole이나 S3 Browser를 통해 데이터에 접근할 때, 많은 데이터 조회에 속도가 느려지는 현상도 목격할 수 있어요.&lt;/p&gt;

&lt;p&gt;S3의 Lifecycle 기능을 이용하여 S3 버킷에 있는 데이터를 삭제하고 관리할 수 잇는 방법을 알아봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;amazon-s3-lifecycle-기능-사용하기&quot;&gt;Amazon S3 Lifecycle 기능 사용하기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;먼저, AWS Concsole로 S3 메뉴로 접근합니다.&lt;/p&gt;

&lt;p&gt;그리고 버킷 리스트 중 정리를 할 S3 버킷을 클릭해 접근해보면 &lt;u&gt;&lt;b&gt;관리&lt;/b&gt;&lt;/u&gt;라는 메뉴가 보여요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EB%B2%84%ED%82%B7%EC%A0%91%EA%B7%BC.JPG&quot; alt=&quot;S3 버킷 접근&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;b&gt;수명 주기 규칙 생성&lt;/b&gt;&lt;/u&gt;버튼을 눌러서 생성화면으로 접근합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%83%9D%EC%84%B1%ED%99%94%EB%A9%B40.JPG&quot; alt=&quot;수명주기 생성화면1&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같은 화면을 볼 수 있어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%83%9D%EC%84%B1%ED%99%94%EB%A9%B41.JPG&quot; alt=&quot;수명주기 생성화면2&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수명 주기의 이름을 생성한 후, 범위를 지정해야 합니다.&lt;/p&gt;

&lt;p&gt;범위를 지정하지 않으면, 모든 객체가 해당 수명 주기의 영향을 받으니 주의해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;보통은 파일명(접두사)로 구분합니다. 접두사를 입력해주시면, 해당 접두사에 포함된 항목만 수명 주기에 영향을 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;접두사란&quot;&gt;접두사란?&lt;/h3&gt;

&lt;p&gt;S3에서 파일의 구조를 보면&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;버킷이름/상위폴더명/하위폴더명/파일명&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;이렇게 된 폴더 구조를 볼 수 있는데, 이는 실제로는 폴더 구조가 아니라 폴더+파일명이 하나의 Key로 취급됩니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에, 접두사는 파일명에 앞에 붙는 Key의 구분자라고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;따라서, 바로 위의 경우는 버킷이름을 제외하고 슬래시를 포함하여(/)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;상위폴더명/하위폴더명/&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;까지가 해당 파일 Key의 접두사라고 보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;수명-주기의-규칙&quot;&gt;수명 주기의 규칙&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%83%9D%EC%84%B1%ED%99%94%EB%A9%B42.JPG&quot; alt=&quot;수명주기 생성화면3&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수명 주기의 규칙은 잘 쓰지 않는 마지막 조건을 제외하고, 4가지 조건을 볼 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스토리지 클래스 간에 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재&lt;/code&gt;버전 반환
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최신&lt;/code&gt; 버전으로 취급되는 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스토리지 클래스 간에 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt;버전 반환
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt; 버전으로 취급되는 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재&lt;/code&gt; 버전 만료
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최신&lt;/code&gt; 버전으로 취급되지 않을 때까지의 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt; 버전 영구 삭제
    &lt;ul&gt;
      &lt;li&gt;해당 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이전&lt;/code&gt; 버전으로 취급되어 영구적으로 삭제될 때까지의 시간입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;저의 경우에는,&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;S3에 업로드된 객체가 30일 후에 이전 버전으로 취급되고,&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;u&gt;이전 버전이 된 지 60일이나 지나면 삭제하고 싶었습니다.&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;결국, 총 90일 후 S3에 적재된 리소스를 삭제하고 싶었으므로,&lt;/p&gt;

&lt;p&gt;2번과, 4번 조건을 이용해 수명 주기를 생성했습니다.&lt;/p&gt;

&lt;p&gt;완료 버튼을 눌러 생성을 완료합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%EC%83%9D%EC%84%B1%EC%99%84%EB%A3%8C.JPG&quot; alt=&quot;생성완료&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상세 화면을 보면 등록된 수명 주기를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/s3lifecycle/%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8%ED%99%95%EC%9D%B8.JPG&quot; alt=&quot;수명 주기 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS S3 Lifecycle 기능을 사용하여 스토리지 요금을 줄이고, 복잡하지 않은 S3 파일 관리가 가능해졌습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞으로는 집에서 잔소리를 좀 듣더라도 데이터만이라도 잘 정리하여&lt;/p&gt;

&lt;p&gt;효과적인 업무를 할 수 있도록 노력합시다.&lt;/p&gt;

&lt;p&gt;그럼 20,000👋&lt;/p&gt;</content><author><name>전지호</name></author><category term="aws" /><summary type="html">S3를 이용하여 로그 및 분석 결과 혹은 파일을 저장하여 사용하다 보면 어느새 너무 많은 양의 데이터가 축적됩니다. 이 중 사용하는 데이터나 파일은 상관이 없으나, 사용하지 않는 데이터가 너무 많이 쌓이면 문제가 발생할 수 도 있습니다. AWS Concsole이나 S3 Browser를 통해 이를 삭제하고 관리할 수 잇는 방법을 알아봅시다.</summary></entry><entry><title type="html">AWS Aurora DB, Mysql DB에서 스케줄러 사용하는 방법</title><link href="http://0.0.0.0:4000/2021/06/02/MysqlEvent-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS Aurora DB, Mysql DB에서 스케줄러 사용하는 방법" /><published>2021-06-02T10:00:00-05:00</published><updated>2021-06-02T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/06/02/MysqlEvent-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/06/02/MysqlEvent-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;aws-auroradb-mysql-db-에서-스케줄러-사용하는-방법-&quot;&gt;AWS AuroraDB, Mysql DB 에서 스케줄러 사용하는 방법 🕘&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS AuroraDB에서 데이터 사용을 용이하게 하기 위해 스케줄러를 사용해봅시다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;AWS에서 사용하는 RDB 데이터베이스인 AuroraDB에서 스케줄러를 사용하는 방법을 설명합니다.&lt;/p&gt;

&lt;p&gt;굉장히 많은 데이터가 일반 RDB에 쌓일 경우, 불가피하게 속도에 영향을 끼칠 수 있습니다.&lt;/p&gt;

&lt;p&gt;한 예로, 1 번의 쿼리로 데이터를 삭제하기 너무 많은 시간이 필요할 수 있습니다.&lt;/p&gt;

&lt;p&gt;스케줄러를 적절히 사용하면 데이터 관리를 용이하게 할 수 있을 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이벤트-스케줄을-생성하는-기본-문법-️&quot;&gt;이벤트 스케줄을 생성하는 기본 문법 ✏️&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;먼저 기본 문법을 알아봅시다. workbench 등을 통해 접근하여 다음과 같은 문법으로 이벤트를 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCHEDULE&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수행&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;반복&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;시간&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMPLETION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRESERVE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;코멘트&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수행할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명령&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실제-쿼리를-작성해봅시다-️&quot;&gt;실제 쿼리를 작성해봅시다. ✏️&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;일단, 매 시간마다 데이터를 삭제하는 예제 쿼리를 작성해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_DELETE_ROW_BEFORE_180DAY&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCHEDULE&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MINUTE&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;분&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;마다&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOUR&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMPLETION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRESERVE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'현재일로 부터 180일 전 데이터는 삭제'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt; 

    &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수행할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스케줄러-onoff&quot;&gt;스케줄러 On/Off&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;쿼리 작성을 완료했다면, 해당 데이터베이스가 스케줄러가 작동가능한 지 확인해봅시다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLES&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'event_scheduler'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.JPG&quot; alt=&quot;이벤트 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;작동이 가능하지 않다면 아래 명령어를 통해 스케줄러 기능을 사용가능하게 바꿔주세요.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GLOBAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_scheduler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AWS에서는 AuroraDB를 처음 만들었을 때, 파라미터 그룹(Parameter groups)이라는 설정값에 의해 스케줄러가 on/off를 할 수 없는 상태로 생성됬을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;AWS console에서 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;데이터 베이스의 파라미터 그룹을 확인해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B7%B8%EB%A3%B9.JPG&quot; alt=&quot;데이터 베이스 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;default.aurora5.6라는 기본 파라미터 그룹으로 생성된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B7%B8%EB%A3%B91.JPG&quot; alt=&quot;파라미터 그룹 확인&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이벤트 스케줄러가 변경이 가능하도록 되어있으나, 기본 파라미터 그룹은 값 변경이 되지 않습니다. 그렇기 때문에, 새 파라미터 그룹을 생성하고 데이터베이스 파라미터 그룹을 변경해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%20%EB%B3%80%EA%B2%BD.JPG&quot; alt=&quot;파라미터 변경&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 파라미터 그룹을 생성했다면 파라미터를 변경 후, 데이터베이스 파라미터 그룹을 생성한 파라미터 그룹으로 변경한다.
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;변경이 가능한 파라미터 그룹이라면 파라미터만 변경한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;적용 후, 데이터베이스 재부팅을 통해 파라미터가 변경이 적용되게 하세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%9E%AC%EB%B6%80%ED%8C%85.JPG&quot; alt=&quot;재부팅&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;재부팅이 완료된 후, 다시 명령어로 확인해봅니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLES&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'event_scheduler'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%20%EB%B3%80%EA%B2%BD%20%EC%99%84%EB%A3%8C.JPG&quot; alt=&quot;파라미터 변경 완료&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 이벤트 스케줄러를 등록할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이벤트-스케줄러-등록-&quot;&gt;이벤트 스케줄러 등록 📅&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;예제 쿼리를 실행합니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_DELETE_ROW_BEFORE_180DAY&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCHEDULE&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MINUTE&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;분&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;마다&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;EVERY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOUR&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMPLETION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRESERVE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'현재일로 부터 180일 전 데이터는 삭제'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt; 

    &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수행할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;등록된 이벤트는 다음 명령어로 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EB%93%B1%EB%A1%9D%EB%90%9C%20%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.JPG&quot; alt=&quot;등록된 이벤트 보기&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;등록된 이벤트를 삭제하려면 다음 명령어로 삭제할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이벤트&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼 20,000 👋&lt;/p&gt;</content><author><name>전지호</name></author><category term="aws" /><category term="sql" /><category term="mysql" /><summary type="html">AWS에서 사용하는 RDB 데이터베이스인 AuroraDB에서 스케줄러를 사용하는 방법을 설명합니다. 굉장히 많은 데이터가 일반 RDB에 쌓일 경우, 불가피하게 속도에 영향을 끼칠 수 있습니다. 한 예로, 1 번의 쿼리로 데이터를 삭제하기 너무 많은 시간이 필요할 수 있습니다. 스케줄러를 적절히 사용하면 데이터 관리를 용이하게 할 수 있을 것입니다.</summary></entry><entry><title type="html">Spark broadcasting을 이용해 기존 머신러닝 라이브러리 속도 개선하기</title><link href="http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98.html" rel="alternate" type="text/html" title="Spark broadcasting을 이용해 기존 머신러닝 라이브러리 속도 개선하기" /><published>2021-05-31T10:00:00-05:00</published><updated>2021-05-31T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98.html">&lt;h1 id=&quot;spark-broadcast&quot;&gt;Spark Broadcast&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리에게 필요한 것은 inference 효율성 😎&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;기존 python ml 라이브러리로 다량의 데이터를 빠르게 처리를 해야 할 때!  &lt;u&gt;Spark broadcasting&lt;/u&gt;을 이용해 inference 속도를 개선할 수 있습니다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spark의-공유-변수&quot;&gt;Spark의 공유 변수&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아피치 스파크&lt;/code&gt;는 SQL, 머신러닝 등 처리를 위한 기본 제공 모듈이 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대규모 데이터 처리용 통합 분석 엔진&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
일반적인 스파크 연산이 클러스터에서 실행될 때 함수에서 사용되는 변수는 각 클러스터에 복제되고 각 노드 연산에서는 독립적입니다. 클러스터 상에서 변수를 공유하는 것은 비효율적이기 때문인데, 일반적인 연산 패턴을 지원하기 위해 아래와 같은 공유 변수를 제공합니다
.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;broadcast variables : 큰 데이터를 효율적으로 처리하는데 사용&lt;/li&gt;
  &lt;li&gt;Accumulators variables : 특정 컬렉션의 정보를 집계하는 데 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;broadcast variables&lt;/code&gt;에 대하여 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spark-broadcast-란&quot;&gt;Spark broadcast 란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;broadcast 변수는 읽기 전용 변수입니다. 모든 노드에 큰 input 데이터셋을 제공할 때 효과적인 방법이라고 할 수 있습니다. 이를 사용하면 효율적인 broadcast 알고리즘을 통해 계산 비용을 줄일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;스파크의 액션들은 기본적으로 여러 단계의 집합으로 실행되는데, 자동적으로 각 단계에 필요한 공유 변수들을 broadcast하는 것입니다.&lt;/p&gt;

&lt;p&gt;Broadcast 변수는 RDD나 Dataframe과 동일한 방식으로 사용될 수 있습니다. (데이터는 serialized 캐싱되고 deserialized 되어 각 테스크로 넘어가게 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
호출 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sc &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; SparkContext&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
var &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Array&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4,5,6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 사용할 공유 변수 var&lt;/span&gt;

broadcastvar &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;일단 broadcast variable이 만들어지면, 클러스터상의 모든 함수에 사용될 수 있습니다. (즉, &lt;b&gt;&lt;u&gt;var은 한 번 이상 노드에 올라가지 않게&lt;/u&gt;&lt;/b&gt; 됩니다.)&lt;/p&gt;

&lt;p&gt;참고로, 한 번 생성된 broadcastvar 객체는 이후 수정될 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
broadcast 된 값을 이용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value 메소드&lt;/code&gt;를 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# value 값에 액세스 하기 위함&lt;/span&gt;
broadcastvar.value

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Array&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4,5,6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sklearn에-spark-broadcast를-적용해-inference-하기&quot;&gt;sklearn에 spark broadcast를 적용해 inference 하기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;python에서 가장 많이 이용되는 mechine learning library는 sklearn일 것입니다. sklearn 에서는 보통 pandas dataframe 을 활용한 데이터를 fit하고 predict 하게 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, KNN (K-Nearest Neighbors)과 같은 알고리즘을 사용하게 된다면 우리는 각 key 값에 대한 각각의 k개의 neighbors를 모두 구해야합니다. 즉, &lt;b&gt;&lt;u&gt;key 값 하나하나에 모든 데이터를 연산&lt;/u&gt;&lt;/b&gt;하게 됩니다.결국 inference 시간이 엄청나게 길어질 수 밖에 없는 구조가 됩니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;b&gt;&lt;u&gt;sklearn model을 broadcast 하는 방식&lt;/u&gt;&lt;/b&gt;을 활용해 효율적으로 처리될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제 코드는 다음과 같습니다. ( knn model 사용 )&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def knn_regressor_broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_pd, &lt;span class=&quot;nv&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;100, &lt;span class=&quot;nv&quot;&gt;n_partitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10, weights &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;uniform&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

  &lt;span class=&quot;c&quot;&gt;# X_train, y_train, X_test, y_test 의 경우 pandas dataframe 형태&lt;/span&gt;
  

  &lt;span class=&quot;c&quot;&gt;# 모델 fit&lt;/span&gt;
  knn &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; KNeighborsRegressor&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;n_neighbors &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; neighbors, weights &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; weights&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; knn.fit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;X_train, y_train&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  
  &lt;span class=&quot;c&quot;&gt;# 여러 배치로 돌리기 위한 함수&lt;/span&gt;
  def batch&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
    yield list&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    
  rdd &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.parallelize&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;X_test, n_partitions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.zipWithIndex&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  b_model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;model&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rdd.mapPartitions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;batch&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.map&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lambda value: &lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;x[0] &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;value], &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;x[1] &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;value]&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;.flatMap&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lambda x: zip&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x[1], b_model.value.predict&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x[0]&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
  
  result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; result.collect&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 &lt;b&gt;model을 broadcast + rdd test data&lt;/b&gt;를 사용하자 Pandas dataframe을 이용해 predict를 하였을 때 Runtime errorrk가 났던 모델을 약 5분 내외로 처리할 수 있었습니다 👏👏&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;부가적인 코드 설명을 잠시 하자면&lt;/p&gt;

&lt;p&gt;mapPartitions의 경우 나눠진 partition내에서 연산을 수행하게 해줍니다&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rdd &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.parallelize&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;1, 2, 3, 4], 2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
def f&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: yield &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
rdd.mapPartitions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.collect&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3, 7]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;즉, broadcast된 모델에 test 데이터를 batch  형태로 분산 처리가 가능해진다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://www.tutorialspoint.com/apache_spark/advanced_spark_programming.htm&quot;&gt;About advaced spark programming - spark broadcast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://sparkbyexamples.com/spark/spark-broadcast-variables/&quot;&gt;Spark Broadcast Varibales&lt;/a&gt;&lt;/p&gt;</content><author><name>김연수</name></author><category term="python" /><category term="sklearn" /><category term="ml" /><category term="spark" /><summary type="html">좀 더 빠른 ML inference를 위해 spark broadcasting을 사용해봅니다.</summary></entry><entry><title type="html">Spark broadcasting을 이용해 기존 머신러닝 라이브러리 속도 개선하기</title><link href="http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98.html" rel="alternate" type="text/html" title="Spark broadcasting을 이용해 기존 머신러닝 라이브러리 속도 개선하기" /><published>2021-05-31T10:00:00-05:00</published><updated>2021-05-31T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/31/Sparkbroadcasting-%EA%B9%80%EC%97%B0%EC%88%98.html">&lt;h1 id=&quot;spark-broadcast&quot;&gt;Spark Broadcast&lt;/h1&gt;
&lt;h2 id=&quot;우리에게-필요한-것은-inference-효율성-&quot;&gt;우리에게 필요한 것은 inference 효율성 😎&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기존 python ml 라이브러리로 다량의 데이터를 빠르게 처리를 해야 할 때!  &lt;u&gt;Spark broadcasting&lt;/u&gt;을 이용해 inference 속도를 개선할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spark의-공유-변수&quot;&gt;Spark의 공유 변수&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;아피치 스파크&lt;/b&gt;는 SQL, 머신러닝 등 처리를 위한 기본 제공 모듈이 있는 &lt;u&gt;대규모 데이터 처리용 통합 분석 엔진&lt;/u&gt;입니다.&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;
일반적인 스파크 연산이 클러스터에서 실행될 때 함수에서 사용되는 변수는 각 클러스터에 복제되고 각 노드 연산에서는 독립적입니다. 클러스터 상에서 변수를 공유하는 것은 비효율적이기 때문인데, 일반적인 연산 패턴을 지원하기 위해 아래와 같은 공유 변수를 제공합니다
.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;broadcast variables : 큰 데이터를 효율적으로 처리하는데 사용&lt;/li&gt;
  &lt;li&gt;Accumulators variables : 특정 컬렉션의 정보를 집계하는 데 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘은 &lt;b&gt;broadcast variables&lt;/b&gt;에 대하여 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spark-broadcast-란&quot;&gt;Spark broadcast 란?&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;broadcast 변수는 읽기 전용 변수입니다. 모든 노드에 큰 input 데이터셋을 제공할 때 효과적인 방법이라고 할 수 있습니다. 이를 사용하면 효율적인 broadcast 알고리즘을 통해 계산 비용을 줄일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;스파크의 액션들은 기본적으로 여러 단계의 집합으로 실행되는데, 자동적으로 각 단계에 필요한 공유 변수들을 broadcast하는 것입니다.&lt;/p&gt;

&lt;p&gt;Broadcast 변수는 RDD나 Dataframe과 동일한 방식으로 사용될 수 있습니다. (데이터는 serialized 캐싱되고 deserialized 되어 각 테스크로 넘어가게 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
호출 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sc &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; SparkContext&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
var &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Array&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4,5,6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 사용할 공유 변수 var&lt;/span&gt;

broadcastvar &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;일단 broadcast variable이 만들어지면, 클러스터상의 모든 함수에 사용될 수 있습니다. (즉, &lt;u&gt;var은 한 번 이상 노드에 올라가지 않게&lt;/u&gt; 됩니다.)&lt;/p&gt;

&lt;p&gt;참고로, 한 번 생성된 broadcastvar 객체는 이후 수정될 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; 
broadcast 된 값을 이용하기 위해서는 &lt;b&gt;value 메소드&lt;/b&gt;를 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# value 값에 액세스 하기 위함&lt;/span&gt;
broadcastvar.value

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Array&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4,5,6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sklearn에-spark-broadcast를-적용해-inference-하기&quot;&gt;sklearn에 spark broadcast를 적용해 inference 하기&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;python에서 가장 많이 이용되는 mechine learning library는 sklearn일 것입니다. sklearn 에서는 보통 pandas dataframe 을 활용한 데이터를 fit하고 predict 하게 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, KNN (K-Nearest Neighbors)과 같은 알고리즘을 사용하게 된다면 우리는 각 key 값에 대한 각각의 k개의 neighbors를 모두 구해야합니다. 즉, &lt;b&gt;key 값 하나하나에 모든 데이터를 연산&lt;/b&gt;하게 됩니다.결국 inference 시간이 엄청나게 길어질 수 밖에 없는 구조가 됩니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;b&gt;&lt;u&gt;sklearn model을 broadcast 하는 방식&lt;/u&gt;&lt;/b&gt;을 활용해 효율적으로 처리될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제 코드는 다음과 같습니다. ( knn model 사용 )&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def knn_regressor_broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_pd, &lt;span class=&quot;nv&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;100, &lt;span class=&quot;nv&quot;&gt;n_partitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10, weights &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;uniform&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

  &lt;span class=&quot;c&quot;&gt;# X_train, y_train, X_test, y_test 의 경우 pandas dataframe 형태&lt;/span&gt;
  

  &lt;span class=&quot;c&quot;&gt;# 모델 fit&lt;/span&gt;
  knn &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; KNeighborsRegressor&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;n_neighbors &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; neighbors, weights &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; weights&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; knn.fit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;X_train, y_train&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  
  &lt;span class=&quot;c&quot;&gt;# 여러 배치로 돌리기 위한 함수&lt;/span&gt;
  def batch&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
    yield list&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    
  rdd &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.parallelize&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;X_test, n_partitions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.zipWithIndex&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  b_model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.broadcast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;model&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rdd.mapPartitions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;batch&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.map&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lambda value: &lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;x[0] &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;value], &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;x[1] &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;value]&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;.flatMap&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lambda x: zip&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x[1], b_model.value.predict&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x[0]&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
  
  result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; result.collect&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 &lt;b&gt;model을 broadcast + rdd test data&lt;/b&gt;를 사용하자 Pandas dataframe을 이용해 predict를 하였을 때 Runtime errorrk가 났던 모델을 약 5분 내외로 처리할 수 있었습니다 👏👏&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;부가적인 코드 설명을 잠시 하자면&lt;/p&gt;

&lt;p&gt;mapPartitions의 경우 나눠진 partition내에서 연산을 수행하게 해줍니다&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rdd &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sc.parallelize&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;1, 2, 3, 4], 2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
def f&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: yield &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
rdd.mapPartitions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.collect&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3, 7]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;즉, broadcast된 모델에 test 데이터를 batch  형태로 분산 처리가 가능해진다고 할 수 있습니다.
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://www.tutorialspoint.com/apache_spark/advanced_spark_programming.htm&quot;&gt;About advaced spark programming - spark broadcast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://sparkbyexamples.com/spark/spark-broadcast-variables/&quot;&gt;Spark Broadcast Varibales&lt;/a&gt;&lt;/p&gt;</content><author><name>김연수</name></author><category term="python" /><category term="sklearn" /><category term="ml" /><category term="spark" /><summary type="html">좀 더 빠른 ML inference를 위해 spark broadcasting을 사용해봅니다.</summary></entry><entry><title type="html">AWS EKS 쿠버네티스에서 JupyterHub 환경 설정하기</title><link href="http://0.0.0.0:4000/2021/05/30/JupyterhubConfig-%EC%A0%84%EC%A7%80%ED%98%B8.html" rel="alternate" type="text/html" title="AWS EKS 쿠버네티스에서 JupyterHub 환경 설정하기" /><published>2021-05-30T10:00:00-05:00</published><updated>2021-05-30T10:00:00-05:00</updated><id>http://0.0.0.0:4000/2021/05/30/JupyterhubConfig-%EC%A0%84%EC%A7%80%ED%98%B8</id><content type="html" xml:base="http://0.0.0.0:4000/2021/05/30/JupyterhubConfig-%EC%A0%84%EC%A7%80%ED%98%B8.html">&lt;h1 id=&quot;쿠버네티스-jupyterhub-설정법-&quot;&gt;쿠버네티스 JupyterHub 설정법 👨‍💻&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;config.yaml을 이용한 사용자 별 환경 구성법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;첫-번째-configyaml이-작업-폴더에-있는지-확인해-주세요&quot;&gt;첫 번째, config.yaml이 작업 폴더에 있는지 확인해 주세요.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;👉 &lt;a href=&quot;/2021/05/27/JupyterhubForK8S-전지호.html&quot;&gt;첫번째 포스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 포스트 처음에 만들었던 config.yaml를 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/config%EC%9C%84%EC%B9%98.JPG&quot; alt=&quot;config.yaml 위치&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;config.yaml을 수정하고 다음 명령어를 입력하면 변경사항이 jupyterhub에 적용됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm upgrade &lt;span class=&quot;nt&quot;&gt;--cleanup-on-fail&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt; jhub &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; jhub &lt;span class=&quot;nt&quot;&gt;--values&lt;/span&gt; config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;두-번째-기본으로-사용되는-jupyter-이미지를-사양에-맡게-변경해봅시다&quot;&gt;두 번째, 기본으로 사용되는 jupyter 이미지를 사양에 맡게 변경해봅시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;다음과 같이 config.yaml을 수정하면 기본 도커이미지가 jupyter/datascience-notebook로 변경됩니다.&lt;/p&gt;

&lt;p&gt;사무실 환경에 맡게 커스텀한 도커이미지를 도커허브에 푸쉬한 뒤 그것을 사용해도 무방합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# You should replace the &quot;latest&quot; tag with a fixed version from:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# https://hub.docker.com/r/jupyter/datascience-notebook/tags/&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# Inspect the Dockerfile at:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# https://github.com/jupyter/docker-stacks/tree/HEAD/datascience-notebook/Dockerfile&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/datascience-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세-번째-jupyterlab을-기본으로-사용해봅시다&quot;&gt;세 번째, jupyterlab을 기본으로 사용해봅시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;defaultUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/lab&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%A3%BC%ED%94%BC%ED%84%B0%EB%9E%A9.JPG&quot; alt=&quot;주피터랩&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;네-번째-다양한-주피터-이미지를-선택할-수-있게-합시다&quot;&gt;네 번째, 다양한 주피터 이미지를 선택할 수 있게 합시다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;profileList에 항목을 추가하면 로그인 시 이미지를 선택하여 jupyter를 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래 예는 pyspark버전과 datascience버전을 선택할 수 있는 예제입니다.&lt;/p&gt;

&lt;p&gt;선택하지 않으면, jupyter/minimal-notebook이 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;defaultUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/lab&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/minimal-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;profileList&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pyspark&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;spark를&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;사용할&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;수&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;일반&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/pyspark-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow가&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설치되어&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/tensorflow-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;7a0c7325e470&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://solution-userstats.s3.ap-northeast-1.amazonaws.com/techblogs/batteryho/%EC%A3%BC%ED%94%BC%ED%84%B0%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%84%A0%ED%83%9D.JPG&quot; alt=&quot;원하는 주피터로 시작&quot; id=&quot;popup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다섯-번째-사용자와-비밀번호를-설정하는-방법&quot;&gt;다섯 번째, 사용자와 비밀번호를 설정하는 방법&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;아래와 같이 입력하면 2명의 관리자 유저, 2명의 일반 유저, 공통 비밀번호로 접근할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;hub&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;Authenticator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;admin_users&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;admin&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;batteryho&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;allowed_users&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;seungjin&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ehdud8565&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;yeonsuuu&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;sanghyunbaek&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;hgchoi16&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;DummyAuthenticator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;비밀번호입력&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;JupyterHub&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;authenticator_class&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dummy&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 생략&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;리소스를-설정하는-방법&quot;&gt;리소스를 설정하는 방법&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;쿠버네티스내에 jupyter notebook들은 기본적으로 각 사용자에게는 1G의 RAM 이 보장 됩니다. 모든 사용자는 1G 이상을 가지고 있지만 가능한 경우 기술적으로 더 많이 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하여 메모리 제한을 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;guarantee는 필요에 의해 남아있는 다른 리소스를 사용하는 것을 의미하고,&lt;/p&gt;

&lt;p&gt;limit는 더이상 리소스를 사용하지 못함을 의미 합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2G&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;guarantee&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1G&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cpu의 제한 또한 다음과 같이 변경할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;.5&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;guarantee&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;.5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gpu-할당하는-방법&quot;&gt;GPU 할당하는 방법&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;tensorflow나 pytorch같은 딥러닝 프레임워크들은 GPU를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하여 gpu 할당이 가능합니다.&lt;/p&gt;

&lt;p&gt;물론, 쿠버네티스 환경에 gpu가 있어야합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;singleuser&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;defaultUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/lab&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/minimal-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;profileList&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pyspark&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;spark를&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;사용할&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;수&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;일반&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/pyspark-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;display_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;MLP&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Notebook&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tensorflow가&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설치되어&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jupyter&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;notebook&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;kubespawner_override&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jupyter/tensorflow-notebook&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;7a0c7325e470&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 해당부분&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;extra_resource_limits&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;nvidia.com/gpu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본적인 사용방법을 알아봤습니다.&lt;/p&gt;

&lt;p&gt;더 많은 정보는 아래 링크에서 확인해주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h2&gt;

&lt;p&gt;👉 &lt;a href=&quot;https://zero-to-jupyterhub.readthedocs.io/en/latest/kubernetes/setup-kubernetes.html&quot;&gt;zero-to-jupyterhub-on-k8s&lt;/a&gt;&lt;/p&gt;</content><author><name>전지호</name></author><category term="docker" /><category term="kubernetes" /><category term="jupyter" /><category term="aws" /><summary type="html">JupyterHub를 구축했다면 사용자 별 환경과 리소스를 구분하기 위한 설정방법을 알아봅시다.</summary></entry></feed>